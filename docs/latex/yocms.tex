%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,spanish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{Yo Cmás}
\date{18 de diciembre de 2020}
\release{}
\author{Comunidad del taller avanzado}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Esta es una documentación realiza por Mateo León, Vicente Villaroel, alumnos del Taller Yo C+ y el tutor Gabriel Carmona, tutor del taller de nivel avanzado.

La principal idea de este documento es realizar un espacio en el cual se presente la materia vista a través del taller y explicaciones a los contest que se han hecho a través del tiempo.

Cualquier aporte es bienvenido.


\chapter{Estructuras de Datos}
\label{\detokenize{edd/edd:estructuras-de-datos}}\label{\detokenize{edd/edd::doc}}
Las estructuras de datos son una forma que el programador tiene para organizar los datos de manera eficiente. Existen diferentes tipos de estructuras de datos, algunas que se pueden aplicar a muchos temas mientras que otras son especializaciadas en tareas específicas.

En este curso vamos a revisar dos tipos: estructuras de datos lineales y las no lineales.


\section{Estructuras de Datos Lineales}
\label{\detokenize{edd/lineales:estructuras-de-datos-lineales}}\label{\detokenize{edd/lineales::doc}}

\subsection{Acerca de}
\label{\detokenize{edd/lineales:acerca-de}}
Estas estructuras se basan en que los elementos estan contiguos, esto quiere decir que los elementos estan ordenados de manera que un elemento va a después del otro.


\subsection{Arrays}
\label{\detokenize{edd/lineales:arrays}}
Los arrays son conjuntos de datos que se almacenan en memoria de manera contigua usando el mismo nombre. Se usan índices para diferenciar los distintos valores del arreglo.

Para crear una arreglo es necesario saber la cantidad de elementos que van a componer nuestro arreglo, pues la cantidad de elementos no se puede cambiar.

Una cosa muy importante que al principio uno suele olvidar es que los índices de los arreglos parten en 0. Es decir, un arreglo de tamaño n puede tomar índices desde el 0 hasta el n\sphinxhyphen{}1.


\subsubsection{Inicialización}
\label{\detokenize{edd/lineales:inicializacion}}
Hay dos formas de inicializar un array, especificando su tamaño o llenandolo con valores por defecto.


\subsubsection{Inicializar un array por su tamaño}
\label{\detokenize{edd/lineales:inicializar-un-array-por-su-tamano}}
Para inicializar un array por su tamaño, lo único que hay que especificar es el nombre de la variable y colocar entre «{[}{]}» el tamaño de nuestro arreglo. Recordar que como los arrays parten en 0, el valor máximo que podremos acceder será el tamaño del array menos 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Inicializar un arreglo de ints de tamaño 38.}
    \PYG{k+kt}{int} \PYG{n}{arreglo}\PYG{p}{[}\PYG{l+m+mi}{38}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Inicializar un array con valores por defecto}
\label{\detokenize{edd/lineales:inicializar-un-array-con-valores-por-defecto}}
Para inicializar un array con valores por defecto, no es necesario especificar el tamaño de nuestro array, pues este está implícito en la cantidad de valores que introducimos.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Esto genera el arreglo siguiente}
    \PYG{c+c1}{//[3, 6, 2, 1]}
    \PYG{k+kt}{int} \PYG{n}{arreglo2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Leer el valor de un arreglo}
\label{\detokenize{edd/lineales:leer-el-valor-de-un-arreglo}}
Para leer un valor de nuestro arreglo, solo hay que especificar el nombre del arreglo y su índice. Notar que sólo se puede acceder a un valor de un arreglo a la vez.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 1}
    \PYG{n}{arreglo2}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Asignar valores a un arreglo}
\label{\detokenize{edd/lineales:asignar-valores-a-un-arreglo}}
Para esto, hay que especificar la variable, el índice al cuál acceder y especificar su nuevo valor. Recordar que el valor del índice puede ser una variable, pero que no puede estar fuera del rango del tamaño de nuestro arreglo.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// El indice 3 de nuestro arreglo, ahora tiene el valor 3}
    \PYG{n}{arreglo2}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Arrays multidimensionales}
\label{\detokenize{edd/lineales:arrays-multidimensionales}}
Un array multidimensional es aquel que requiuere de más de un índice para ser llamado, como su nombre lo indica, es útil para cuando necesitamos acceder a datos que requieren más de una dimensión, como por ejemplo valores dentro de una malla. Otra forma de enternder los arrays multidimensionales es como un arreglo de arreglos (de arreglos de arreglos.. n veces, siendo n la cantidad de dimensiones). Los arreglos de 2 dimensiones también son conocidos como matrices.


\subsubsection{Inicializar un arreglo multidimensional}
\label{\detokenize{edd/lineales:inicializar-un-arreglo-multidimensional}}
Para esto, hay que especificar el tamaño de cada dimensión del array. Notar que la regla de que empiezan en 0 y terminan en n\sphinxhyphen{}1 se sigue cumpliendo. Es posible asignarles valores predeterminados, pero creo que eso se va poniendo exponencialmente más psicópata a medida de que vas incrementando las dimensiones del array a crear, por lo que no lo voy a demostrar.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k+kt}{int} \PYG{n}{matriz}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{tridimensional}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Asignar valores en un arreglo multidimensional}
\label{\detokenize{edd/lineales:asignar-valores-en-un-arreglo-multidimensional}}
Es muy similar a cómo se hace en un arreglo unidimensional, solo que se especifica cada índice.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{n}{matriz}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
    \PYG{n}{tridimensional}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\end{sphinxVerbatim}

\#\# Vectors (vectores) \{\#vectors\textendash{}vectores\}

Los vectores son como arreglos, excepto de que el tamaño es dinámico, es decir, se puede cambiar.


\subsubsection{Inicializar un vector}
\label{\detokenize{edd/lineales:inicializar-un-vector}}
Incluimos la librería:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\end{sphinxVerbatim}

Inicializamos nuestro vector «vec»:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Inicializa un vector de tamaño 3 con todos sus valores = 0}
    \PYG{c+c1}{// Tanto el tamaño como valor son opcionales.}
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{n}{vector} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Asignar un valor}
\label{\detokenize{edd/lineales:asignar-un-valor}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Asigna el valor \PYGZdq{}1\PYGZdq{} al índice 2 (es decir, al 3er valor del vector)}
    \PYG{n}{vec}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{push back (empujar atrás)}
\label{\detokenize{edd/lineales:push-back-empujar-atras}}
Si no sabemos el tamaño de nuestro vector, podemos simplemente usar push\_back(valor); para enviar es valor al final del vector.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Inserta un 1 al final del vector}
    \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Por ejemplo, se podría usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{vector} \PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{vec2}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{;}
    \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{n}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{valor}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{valor}\PYG{p}{;}
        \PYG{n}{vec2}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{pop back (quitar atrás)}
\label{\detokenize{edd/lineales:pop-back-quitar-atras}}
Elimina el último valor del vector.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// En este caso, elimina el 1}
    \PYG{n}{vec}\PYG{p}{.}\PYG{n}{pop\PYGZus{}back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{insert (insertar)}
\label{\detokenize{edd/lineales:insert-insertar}}
Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que estén más adelante, lo que es lento.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Inserta el valor 4 al índice 2}
    \PYG{n}{vec}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{erase (borrar)}
\label{\detokenize{edd/lineales:erase-borrar}}
Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Elimina el valor con índice 2}
    \PYG{c+c1}{// En nuestro caso, el 4 que insertamos antes.}
    \PYG{n}{vec}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Iteradores de un arreglo}
\label{\detokenize{edd/lineales:iteradores-de-un-arreglo}}
Hay ciertos iteradores que podemos usar en un arreglo que nos ayudarán en algunos casos, como por ejemplo si quieremos recorrer un arreglo. Estos son:
\begin{itemize}
\item {} 
begin() \textendash{} Iterador que accede al primer valor del arreglo.

\item {} 
end() \textendash{} Accede al final del arreglo.

\item {} 
rbegin() \textendash{} Accede al ultimo elemento del arreglo

\item {} 
rend \textendash{} Accede al inicio del arreglo

\end{itemize}


\subsection{Stacks (pilas)}
\label{\detokenize{edd/lineales:stacks-pilas}}
La pila es una estructura de datos lineal al que sólo puedes acceder al último elemento que fue insertado. Imagina una pila de platos, por ejemplo.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{stack} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{n}{pilita}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{push (empujar)}
\label{\detokenize{edd/lineales:push-empujar}}
Empuja un dato a la cima de la pila.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Empuja un 8 a la cima de la pila.}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{top (cima)}
\label{\detokenize{edd/lineales:top-cima}}
Lee lo que hay en la cima de la pila.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Siguiendo el ejemplo anterior}
    \PYG{c+c1}{// Esto retorna 8}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{pop (quitar)}
\label{\detokenize{edd/lineales:pop-quitar}}
Remueve el dato de la cima de la pila.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Siguiendo el ejemplo anterior}
    \PYG{c+c1}{// Remueve el 8}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{empty (vacío)}
\label{\detokenize{edd/lineales:empty-vacio}}
Retorna 1 si la pila está vacía, de lo contrario retorna 0.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 1 ya que nuestra pila está vacía.}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{size (tamaño)}
\label{\detokenize{edd/lineales:size-tamano}}
Retorna el tamaño de nuestra pila.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 0 ya que nuestra pila no tiene datos.}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Queues (colas)}
\label{\detokenize{edd/lineales:queues-colas}}
La cola es una estructura de datos lineal al que sólo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{queue} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{n}{colita}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{push (empujar)}
\label{\detokenize{edd/lineales:id1}}
Añade un dato al final de la cola.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{front (frente)}
\label{\detokenize{edd/lineales:front-frente}}
Lee el dato que está al frente de la cola.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Siguiendo el ejemplo construido antes}
    \PYG{c+c1}{// Retorna 5, ya que fue lo primero que empujamos a la cola}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{front}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{pop (quitar)}
\label{\detokenize{edd/lineales:id2}}
Remueve el dato que está al frente de la cola

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Remueve el 5}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora está primero).}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{front}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{empty (vacío)}
\label{\detokenize{edd/lineales:id3}}
Retorna 1 si la cola está vacía, de lo contrario retorna 0.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 1 ya que nuestra cola está vacía.}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{size (tamaño)}
\label{\detokenize{edd/lineales:id4}}
Retorna el tamaño de nuestra cola.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 0 ya que nuestra cola no tiene datos.}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Estructuras de Datos No Lineales}
\label{\detokenize{edd/no_lineales:estructuras-de-datos-no-lineales}}\label{\detokenize{edd/no_lineales::doc}}

\subsection{Acerca de}
\label{\detokenize{edd/no_lineales:acerca-de}}
A diferencia de las EDD lineales, las no lineales se basan en el hecho de que ahora los elementos no estan contiguos, sino que la forma de buscarlos sigue alguna otra lógica que no sea mirar el siguiente.

Algunos ejemplos son:
\begin{itemize}
\item {} 
Árboles binarios

\item {} 
Tablas de hashing

\end{itemize}


\subsection{Set (conjunto)}
\label{\detokenize{edd/no_lineales:set-conjunto}}
Es una EDD que consiste en organizar elementos no repetidos. Esto quiere decir que cada elemento va a encontrar una y una sola vez en el conjunto.


\subsubsection{Inicialización}
\label{\detokenize{edd/no_lineales:inicializacion}}
Incluimos la librería:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}set\PYGZgt{}}
\end{sphinxVerbatim}

Inicializamos nuestro conjunto:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{set} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{n}{conjunto}\PYG{p}{;} \PYG{c+c1}{// int puede ser reemplazado con cualquier otro tipo de dato}
\end{sphinxVerbatim}


\subsubsection{insert (Insertar)}
\label{\detokenize{edd/no_lineales:insert-insertar}}
Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya existía o no. En el ejemplo de abajo, usamos .second para comprobar si se insertó correctamente o no.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna TRUE ya que no estaba anteriormente}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{.}\PYG{n}{second}\PYG{p}{)}
            \PYG{c+c1}{// Retorna FALSE ya que ya había un 10.}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ganai}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{k}{if} \PYG{p}{(}\PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{.}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{no ganai}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{find (Encontrar)}
\label{\detokenize{edd/no_lineales:find-encontrar}}
Busca un elemento en el set y si lo encuentra retorna un iterador al valor. De lo contrario, retorna conjunto.end();

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ganai}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{erase (borrar)}
\label{\detokenize{edd/no_lineales:erase-borrar}}
Puedes borrar un valor si le entregas el iterador al valor.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{set} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}}\PYG{p}{.}\PYG{p}{.} \PYG{n}{code}\PYG{o}{:}\PYG{o}{:} \PYG{n+nl}{cpp}
\PYG{p}{:}\PYG{n}{number}\PYG{o}{\PYGZhy{}}\PYG{n+nl}{lines}\PYG{p}{:} \PYG{n}{iterator} \PYG{n}{it} \PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Iterar a través de un conjunto}
\label{\detokenize{edd/no_lineales:iterar-a-traves-de-un-conjunto}}
Puedes iterar a través de un conjunto con los valores ya ordenados con un iterador:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Imprime 10 11 20 30 40}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{it}\PYG{p}{)}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{it} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Map (mapa, tabla de hashing)}
\label{\detokenize{edd/no_lineales:map-mapa-tabla-de-hashing}}
Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logarítmico con la implementación de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.


\subsubsection{Ejemplo cotidiano}
\label{\detokenize{edd/no_lineales:ejemplo-cotidiano}}\begin{itemize}
\item {} 
Libros:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Título (Llave)
&\sphinxstyletheadfamily 
Autor (Valor)
\\
\hline
The C Programming Language
&
Brian Keringhan
\\
\hline
The AWK Programming Language
&
Brian Keringhan
\\
\hline
1984
&
George Orwell
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\item {} 
Curso:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Apellido
&\sphinxstyletheadfamily 
Cantidad de alumnos con el apellido
\\
\hline
Gonzalez
&
3
\\
\hline
Perez
&
2
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\end{itemize}


\subsubsection{Inicializar \{\#inicializar\}}
\label{\detokenize{edd/no_lineales:inicializar-inicializar}}
Incluimos la librería de map:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}map\PYGZgt{}}
\end{sphinxVerbatim}

Inicializamos el mapa curso:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{curso}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Insert (insertar)}
\label{\detokenize{edd/no_lineales:id1}}\begin{itemize}
\item {} 
Forma 1:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{curso}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{perez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Forma 2:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{curso}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gonzalez, 3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Operar con los valores}
\label{\detokenize{edd/no_lineales:operar-con-los-valores}}
Se puede operar con el valor tomando la llave.
Ejemplo 1:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Incrementar el valor de la llave perez, por ejemplo.}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{curso}\PYG{p}{.}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{perez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Ejemplo 2:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{curso}\PYG{p}{.}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{perez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// El output será 2.}
\end{sphinxVerbatim}

Cuidado con operar con valores no existentes, pues los inicializará de una forma inesperada.


\subsubsection{Find (encontrar)}
\label{\detokenize{edd/no_lineales:id2}}
Retorna un iterador, si no lo encuentra, apunta a map.end().
Asignamos el iterador \sphinxcode{\sphinxupquote{it}} a gonzalez, y luego lo usamos:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{.}\PYG{p}{.} \PYG{n}{code}\PYG{o}{:}\PYG{o}{:} \PYG{n+nl}{cpp}
\PYG{p}{:}\PYG{n}{number}\PYG{o}{\PYGZhy{}}\PYG{n+nl}{lines}\PYG{p}{:} \PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
    \PYG{n}{it} \PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gonzalez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hay }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{first} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ en el curso:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Llave: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{first} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Valor: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Podemos incluso operar usando los iteradores:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{o}{+}\PYG{n}{second}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Erase (borrar)}
\label{\detokenize{edd/no_lineales:id3}}\begin{itemize}
\item {} 
Forma 1:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{it} \PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{perez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{curso}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Forma 2:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{curso}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gonzalez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Recorrer los valores de un mapa}
\label{\detokenize{edd/no_lineales:recorrer-los-valores-de-un-mapa}}
Es exactamente igual que en un conjunto:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{it}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Llave: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{first} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Valor: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Dudas que no dejan dormir}
\label{\detokenize{edd/no_lineales:dudas-que-no-dejan-dormir}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
¿Qué pasa si modifico una llave?

\end{enumerate}

No se puede, tu código no compilará pues es ilegal hacerlo 👮🚓🚨
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
¿Puedo buscar con el second?

\end{enumerate}

No, en ese caso recomendamos otra estructura, o tener dos maps 👀
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
¿Puedo tener un map dentro de un map?

\end{enumerate}

Si, pero es de psicópata buscar dentro de ese map.


\chapter{Algoritmos de Ordenamiento}
\label{\detokenize{ordenamiento/ordenamiento:algoritmos-de-ordenamiento}}\label{\detokenize{ordenamiento/ordenamiento::doc}}
Uno de los problemas más clásicos de la informática es el problema de ordenamiento, este corresponde a tomo un grupo de datos y los ordenan a base de algún criterio. Hay muchos algoritmos actualmente, vamos a revisar en detalle tres algoritmos. Dos que corresponden a algoritmos que siguen la técnica de fuerza bruta y uno que consiste a decrecer y conquistar. Estos si bien no son los algoritmos más eficientes, son muy útiles para entende la base del ordenamiento.


\section{Algoritmos de Fuerza Bruta}
\label{\detokenize{ordenamiento/fuerza_bruta:algoritmos-de-fuerza-bruta}}\label{\detokenize{ordenamiento/fuerza_bruta::doc}}

\subsection{Acerca de}
\label{\detokenize{ordenamiento/fuerza_bruta:acerca-de}}
Los algoritmos de fuerza bruta son algoritmo en general simples, que realizan una idea de “”Todos con todos””. Esto puede llegar a ser muy costoso en complejidad.


\subsection{Bubble sort}
\label{\detokenize{ordenamiento/fuerza_bruta:bubble-sort}}\begin{itemize}
\item {} 
Se van comparando los elementos, haciendo que los más grandes suban en el arreglo, como una burbuja.

\item {} 
Da lo mismo cómo estén ordenadas las cosas, porque puedes modificar la función de comparación.

\item {} 
Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo.

\item {} 
Por ejemplo, se podría usar para contar el número de inversiones que hay que hacer.

\end{itemize}


\subsubsection{Ejemplo}
\label{\detokenize{ordenamiento/fuerza_bruta:ejemplo}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Step
&
Pos 0
&
Pos 1
&
Pos 2
&
Pos 3
\\
\hline
0
&
5
&
3
&
4
&
1
\\
\hline
1
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{3}
&
4
&
1
\\
\hline
2
&
3
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{4}
&
1
\\
\hline
3
&
3
&
4
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{1}
\\
\hline
4
&
3
&
4
&
1
&
\sphinxstylestrong{5}
\\
\hline
5
&
\sphinxstyleemphasis{3}
&
\sphinxstyleemphasis{4}
&
1
&
\sphinxstylestrong{5}
\\
\hline
6
&
3
&
\sphinxstyleemphasis{1}
&
\sphinxstyleemphasis{4}
&
\sphinxstylestrong{5}
\\
\hline
7
&
3
&
1
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
8
&
\sphinxstyleemphasis{3}
&
\sphinxstyleemphasis{1}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
9
&
1
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
10
&
\sphinxstylestrong{1}
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsubsection{Código}
\label{\detokenize{ordenamiento/fuerza_bruta:codigo}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{aux} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aux}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{bubblesort} \PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Insertion sort}
\label{\detokenize{ordenamiento/fuerza_bruta:insertion-sort}}\begin{itemize}
\item {} 
Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y así hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.

\end{itemize}


\subsubsection{Ejemplo}
\label{\detokenize{ordenamiento/fuerza_bruta:id1}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Step
&
Pos 0
&
Pos 1
&
Pos 2
&
Pos 3
\\
\hline
0
&
5
&
3
&
4
&
1
\\
\hline
1
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{3}
&
4
&
1
\\
\hline
2
&
\sphinxstylestrong{3}
&
5
&
4
&
1
\\
\hline
3
&
3
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{4}
&
1
\\
\hline
4
&
\sphinxstyleemphasis{3}
&
\sphinxstyleemphasis{4}
&
5
&
1
\\
\hline
5
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
5
&
1
\\
\hline
6
&
3
&
4
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{1}
\\
\hline
7
&
3
&
\sphinxstyleemphasis{4}
&
\sphinxstyleemphasis{1}
&
5
\\
\hline
8
&
\sphinxstyleemphasis{3}
&
\sphinxstyleemphasis{1}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
9
&
\sphinxstylestrong{1}
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsubsection{Código}
\label{\detokenize{ordenamiento/fuerza_bruta:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{aux} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aux}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{insertion\PYGZus{}sort}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//caso swap}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
              \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{j}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{//caso no swap = todo ok todo correcto :]}
            \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]} \PYG{o}{|}\PYG{o}{|} \PYG{n}{j} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Nota: este código fue robado de Julieta Coloma}


\section{Algoritmos de Decrecer y Conquistar}
\label{\detokenize{ordenamiento/dec_conq:algoritmos-de-decrecer-y-conquistar}}\label{\detokenize{ordenamiento/dec_conq::doc}}

\subsection{Acerca de}
\label{\detokenize{ordenamiento/dec_conq:acerca-de}}
Rellenar


\subsection{Selection sort}
\label{\detokenize{ordenamiento/dec_conq:selection-sort}}\begin{itemize}
\item {} 
Tiene dos sub\sphinxhyphen{}arreglos, uno de elementos ya ordenados y uno de los elementos resantes.

\item {} 
El arreglo ya ordenado parte vacío.

\item {} 
Busca el valor mínimo entre los elementos no ordenados y lo añade al final de los ordenados.

\end{itemize}


\subsubsection{Ejemplo}
\label{\detokenize{ordenamiento/dec_conq:ejemplo}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Step
&
Pos 0
&
Pos 1
&
Pos 2
&
Pos 3
\\
\hline
0
&
5
&
3
&
4
&
1
\\
\hline
1
&
5
&
3
&
4
&
\sphinxstyleemphasis{1}
\\
\hline
2
&
\sphinxstylestrong{1}
&
5
&
\sphinxstyleemphasis{3}
&
4
\\
\hline
3
&
\sphinxstylestrong{1}
&
\sphinxstylestrong{3}
&
5
&
\sphinxstyleemphasis{4}
\\
\hline
4
&
\sphinxstylestrong{1}
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsubsection{Código de ejemplo}
\label{\detokenize{ordenamiento/dec_conq:codigo-de-ejemplo}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k+kt}{void} \PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{aux} \PYG{o}{=} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{vec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=} \PYG{n}{aux}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{selectionSort}\PYG{p}{(}\PYG{n}{vector} \PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//tamaño :D}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//}
                    \PYG{k+kt}{int} \PYG{n}{min\PYGZus{}in} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j}\PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{size}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{min\PYGZus{}in}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                                    \PYG{n}{min\PYGZus{}in}\PYG{o}{=}\PYG{n}{j}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{swap}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{,} \PYG{n}{min\PYGZus{}in}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Nota: este código fue robado de Natalia Carrión}


\chapter{Algoritmos de búsqueda}
\label{\detokenize{busqueda/busqueda:algoritmos-de-busqueda}}\label{\detokenize{busqueda/busqueda::doc}}
Otro problema muy recurrente dentro de la programación es el buscar uno o más elementos dentro de un grupo de datos. Para ello se han desarrollado varios algoritmos de tal forma de optimizar esta busqueda.

Los dos principales y más nombrados son la búsqueda lineal y binaria. Estas dos búsquedas se detallarán para comprender su uso y benificio.


\section{Búsqueda Lineal}
\label{\detokenize{busqueda/lineal:busqueda-lineal}}\label{\detokenize{busqueda/lineal::doc}}

\subsection{Acerca de}
\label{\detokenize{busqueda/lineal:acerca-de}}
La búsqueda lineal es un algoritmo se trata de pasar elemento por elemento hasta encontrar el correcto. Esto lo hace de forma secuencial, de ahí el nombre lineal.

Entonces analizando, si uno tiene \sphinxstylestrong{N} elementos toma un elemento y ve si es el correcto. Si corresponde listo ganamos, si no pasa al siguiente. Esto lo repite hasta el último elemento.

Este algoritmo tiene complejidad \sphinxstylestrong{O(N)}. La principal gracia de este algoritmo es cuando el grupo de elementos no están ordenados por lo cual uno no sabría como moverse. En la siguiente sección se revisará un algoritmo para cuando el grupo este ordenado.


\subsection{Ejemplo}
\label{\detokenize{busqueda/lineal:ejemplo}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline

Step
&
Pos 0
&
Pos 1
&
Pos 2
&
Pos 3
&
Ele
\\
\hline
0
&
4
&
2
&
5
&
1
&
5
\\
\hline
1
&
\sphinxstylestrong{4}
&
2
&
5
&
1
&
5
\\
\hline
2
&
4
&
\sphinxstylestrong{2}
&
5
&
1
&
5
\\
\hline
3
&
4
&
2
&
\sphinxstylestrong{5}
&
1
&
5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Aquí se ve como en la iteración número 3 encuentra el elemento por lo deja de revisar :D.


\subsection{Código}
\label{\detokenize{busqueda/lineal:codigo}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{linealSearch}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ele}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ele}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Retorna la posicion en que se encuentra}
                    \PYG{k}{return} \PYG{n}{i}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Retorna \PYGZhy{}1 en caso de que el elemento no este}
    \PYG{k}{return} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Búsqueda Binaria}
\label{\detokenize{busqueda/binaria:busqueda-binaria}}\label{\detokenize{busqueda/binaria::doc}}

\subsection{Acerca de}
\label{\detokenize{busqueda/binaria:acerca-de}}
La búsqueda binaria es un algoritmo de \sphinxstyleemphasis{divide and conquer} (dividir y
conquistar), que nos permite encontrar un elemento dentro de una
estructura \sphinxstylestrong{ordenada} rápidamente. Al ejecutarse, toma el centro de un
arreglo y comprueba si el valor que se busca es igual al del centro. De
no serlo, verifica si el valor es menor o mayor al del centro.

Si el valor es mayor al del centro, se ignoran todos los valores
anteriores al centro, dividiendo la cantidad de números a la mitad.

Si el valor es menor al del centro, se ignoran todos los valores de
después del centro, dividiendo la cantidad de números a la mitad.

La complejidad de este algoritmo es \sphinxstylestrong{O(log(N))}, comparada con un
algoritmo lineal, que en el peor de los casos tiene complejidad
\sphinxstylestrong{O(N)}.

Pero hay que notar que para aplicar este algoritmo uno debe tener el grupo ordenado, debido a que si no esta ordenado no hay forma de poder saber hacia donde moverse según la respuesta dada a la comparación.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ejemplos
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
en la vida real
\begin{quote}

Ir al medio de un diccionario, y buscar alfabéticamente, tomando
una palabra central (más o menos), viendo si la palabra que
queremos está antes o después y repetir el proceso de buscar una
palabra central.
\end{quote}

\item {} 
Ejemplo computacional
\begin{quote}

En esta imágen, se usa la búsqueda binaria para encontrar el 19.
\sphinxincludegraphics{{f0801}.png}
\end{quote}

\end{enumerate}

\end{enumerate}


\subsection{Uso mediante la librería STL}
\label{\detokenize{busqueda/binaria:uso-mediante-la-libreria-stl}}\begin{itemize}
\item {} 
Importar
\begin{quote}

Podemos directamente importar toda la stl o podemos importar la
librería \textless{}algorithm\textgreater{} de la siguiente forma:
\end{quote}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
binary\_search()
\begin{quote}

La librería STL ya incluye binary search, si queremos saber si el valor 3 está en un vector, podemos ejecutar:
\end{quote}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{binary\PYGZus{}search} \PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Se encuentra el valor 3 en nuestro vector}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No hay ningún 3 en nuestro vector}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Retorna un \sphinxstyleemphasis{bool}.
\begin{itemize}
\item {} 
lower\_bound() (límite inferior)
\begin{quote}

La función lower\_bound() de la librería STL retorna un puntero a un valor \sphinxstylestrong{superior} o, si es posible, \sphinxstylestrong{igual} al entregado dentro de una estructura ordenada.

Si todos los elementos en el arreglo son inferiores al valor pedido, se entrega el último elemento del arreglo. Si los elementos del arreglo son superiores al valor pedido, se entrega el primer elemento del arreglo.

Por ejemplo:
\end{quote}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{\PYGZob{}} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{50} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Valor de retorno: un iterador que apunta hacia \sphinxstylestrong{30} (el primero en el arreglo, en la posición {[}2{]})
\begin{itemize}
\item {} 
upper\_bound() (límite superior)
\begin{quote}

La función upper$_{\text{bound}}$() de la librería STL nos entrega un puntero a un valor \sphinxstylestrong{superior} al pedido en un arreglo ordenado.

En el caso de que no haya un valor superior al pedido, nos entrega el último valor del arreglo.

Por ejemplo:
\end{quote}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{o}{*}\PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Valor de retorno: iterador al \sphinxstylestrong{40} (posición {[}4{]})


\subsection{Implementaciones propias}
\label{\detokenize{busqueda/binaria:implementaciones-propias}}

\subsubsection{Implementación con while}
\label{\detokenize{busqueda/binaria:implementacion-con-while}}\begin{quote}

Esta implementación nos retorna el índice del número a buscar dentro de un arreglo.
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{binarySearch}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{r}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{k}{while} \PYG{p}{(}\PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{r}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Esto es lo mismo que hacer (r + l) / 2}
        \PYG{k+kt}{int} \PYG{n}{m} \PYG{o}{=} \PYG{n}{l} \PYG{o}{+} \PYG{p}{(}\PYG{n}{r} \PYG{o}{\PYGZhy{}} \PYG{n}{l}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}

        \PYG{c+c1}{// Revisa si x esta al medio}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{m}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// Si x es mayor, ignorar la izquierda}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{l} \PYG{o}{=} \PYG{n}{m} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Si x es menor, ignorar la derecha}
        \PYG{k}{else}\PYG{p}{\PYGZob{}}
            \PYG{n}{r} \PYG{o}{=} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Implementación recursiva}
\label{\detokenize{busqueda/binaria:implementacion-recursiva}}\begin{quote}

Esta implementación nos retorna el índice del número a buscar dentro de un arreglo.
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{binarySearch}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{r}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{r} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Esto es lo mismo que hacer (r + l) / 2}
        \PYG{k+kt}{int} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{l} \PYG{o}{+} \PYG{p}{(}\PYG{n}{r} \PYG{o}{\PYGZhy{}} \PYG{n}{l}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}

        \PYG{c+c1}{// Revisa si x esta al medio}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{mid}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// Si x es mayor, ignorar la izquierda}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{binarySearch}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{l}\PYG{p}{,} \PYG{n}{mid} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Si x es mayor, ignorar la derecha}
        \PYG{k}{return} \PYG{n}{binarySearch}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{mid} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}



\renewcommand{\indexname}{Índice}
\printindex
\end{document}