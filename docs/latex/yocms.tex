%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,spanish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{Yo Cm√°s}
\date{18 de diciembre de 2020}
\release{}
\author{Comunidad del taller avanzado}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Esta es una documentaci√≥n realiza por Mateo Le√≥n, Vicente Villaroel, alumnos del Taller Yo C+ y el tutor Gabriel Carmona, tutor del taller de nivel avanzado.

La principal idea de este documento es realizar un espacio en el cual se presente la materia vista a trav√©s del taller y explicaciones a los contest que se han hecho a trav√©s del tiempo.

Cualquier aporte es bienvenido.


\chapter{Estructuras de Datos}
\label{\detokenize{edd/edd:estructuras-de-datos}}\label{\detokenize{edd/edd::doc}}
Las estructuras de datos son una forma que el programador tiene para organizar los datos de manera eficiente. Existen diferentes tipos de estructuras de datos, algunas que se pueden aplicar a muchos temas mientras que otras son especializaciadas en tareas espec√≠ficas.

En este curso vamos a revisar dos tipos: estructuras de datos lineales y las no lineales.


\section{Estructuras de Datos Lineales}
\label{\detokenize{edd/lineales:estructuras-de-datos-lineales}}\label{\detokenize{edd/lineales::doc}}

\subsection{Acerca de}
\label{\detokenize{edd/lineales:acerca-de}}
Estas estructuras se basan en que los elementos estan contiguos, esto quiere decir que los elementos estan ordenados de manera que un elemento va a despu√©s del otro.


\subsection{Arrays}
\label{\detokenize{edd/lineales:arrays}}
Los arrays son conjuntos de datos que se almacenan en memoria de manera contigua usando el mismo nombre. Se usan √≠ndices para diferenciar los distintos valores del arreglo.

Para crear una arreglo es necesario saber la cantidad de elementos que van a componer nuestro arreglo, pues la cantidad de elementos no se puede cambiar.

Una cosa muy importante que al principio uno suele olvidar es que los √≠ndices de los arreglos parten en 0. Es decir, un arreglo de tama√±o n puede tomar √≠ndices desde el 0 hasta el n\sphinxhyphen{}1.


\subsubsection{Inicializaci√≥n}
\label{\detokenize{edd/lineales:inicializacion}}
Hay dos formas de inicializar un array, especificando su tama√±o o llenandolo con valores por defecto.


\subsubsection{Inicializar un array por su tama√±o}
\label{\detokenize{edd/lineales:inicializar-un-array-por-su-tamano}}
Para inicializar un array por su tama√±o, lo √∫nico que hay que especificar es el nombre de la variable y colocar entre ¬´{[}{]}¬ª el tama√±o de nuestro arreglo. Recordar que como los arrays parten en 0, el valor m√°ximo que podremos acceder ser√° el tama√±o del array menos 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Inicializar un arreglo de ints de tama√±o 38.}
    \PYG{k+kt}{int} \PYG{n}{arreglo}\PYG{p}{[}\PYG{l+m+mi}{38}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Inicializar un array con valores por defecto}
\label{\detokenize{edd/lineales:inicializar-un-array-con-valores-por-defecto}}
Para inicializar un array con valores por defecto, no es necesario especificar el tama√±o de nuestro array, pues este est√° impl√≠cito en la cantidad de valores que introducimos.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Esto genera el arreglo siguiente}
    \PYG{c+c1}{//[3, 6, 2, 1]}
    \PYG{k+kt}{int} \PYG{n}{arreglo2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Leer el valor de un arreglo}
\label{\detokenize{edd/lineales:leer-el-valor-de-un-arreglo}}
Para leer un valor de nuestro arreglo, solo hay que especificar el nombre del arreglo y su √≠ndice. Notar que s√≥lo se puede acceder a un valor de un arreglo a la vez.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 1}
    \PYG{n}{arreglo2}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Asignar valores a un arreglo}
\label{\detokenize{edd/lineales:asignar-valores-a-un-arreglo}}
Para esto, hay que especificar la variable, el √≠ndice al cu√°l acceder y especificar su nuevo valor. Recordar que el valor del √≠ndice puede ser una variable, pero que no puede estar fuera del rango del tama√±o de nuestro arreglo.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// El indice 3 de nuestro arreglo, ahora tiene el valor 3}
    \PYG{n}{arreglo2}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Arrays multidimensionales}
\label{\detokenize{edd/lineales:arrays-multidimensionales}}
Un array multidimensional es aquel que requiuere de m√°s de un √≠ndice para ser llamado, como su nombre lo indica, es √∫til para cuando necesitamos acceder a datos que requieren m√°s de una dimensi√≥n, como por ejemplo valores dentro de una malla. Otra forma de enternder los arrays multidimensionales es como un arreglo de arreglos (de arreglos de arreglos.. n veces, siendo n la cantidad de dimensiones). Los arreglos de 2 dimensiones tambi√©n son conocidos como matrices.


\subsubsection{Inicializar un arreglo multidimensional}
\label{\detokenize{edd/lineales:inicializar-un-arreglo-multidimensional}}
Para esto, hay que especificar el tama√±o de cada dimensi√≥n del array. Notar que la regla de que empiezan en 0 y terminan en n\sphinxhyphen{}1 se sigue cumpliendo. Es posible asignarles valores predeterminados, pero creo que eso se va poniendo exponencialmente m√°s psic√≥pata a medida de que vas incrementando las dimensiones del array a crear, por lo que no lo voy a demostrar.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k+kt}{int} \PYG{n}{matriz}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{tridimensional}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Asignar valores en un arreglo multidimensional}
\label{\detokenize{edd/lineales:asignar-valores-en-un-arreglo-multidimensional}}
Es muy similar a c√≥mo se hace en un arreglo unidimensional, solo que se especifica cada √≠ndice.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{n}{matriz}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
    \PYG{n}{tridimensional}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\end{sphinxVerbatim}

\#\# Vectors (vectores) \{\#vectors\textendash{}vectores\}

Los vectores son como arreglos, excepto de que el tama√±o es din√°mico, es decir, se puede cambiar.


\subsubsection{Inicializar un vector}
\label{\detokenize{edd/lineales:inicializar-un-vector}}
Incluimos la librer√≠a:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\end{sphinxVerbatim}

Inicializamos nuestro vector ¬´vec¬ª:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Inicializa un vector de tama√±o 3 con todos sus valores = 0}
    \PYG{c+c1}{// Tanto el tama√±o como valor son opcionales.}
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{n}{vector} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Asignar un valor}
\label{\detokenize{edd/lineales:asignar-un-valor}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Asigna el valor \PYGZdq{}1\PYGZdq{} al √≠ndice 2 (es decir, al 3er valor del vector)}
    \PYG{n}{vec}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{push back (empujar atr√°s)}
\label{\detokenize{edd/lineales:push-back-empujar-atras}}
Si no sabemos el tama√±o de nuestro vector, podemos simplemente usar push\_back(valor); para enviar es valor al final del vector.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Inserta un 1 al final del vector}
    \PYG{n}{vec}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Por ejemplo, se podr√≠a usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{vector} \PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{vec2}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{;}
    \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{n}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{valor}\PYG{p}{;}
        \PYG{n}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{valor}\PYG{p}{;}
        \PYG{n}{vec2}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{pop back (quitar atr√°s)}
\label{\detokenize{edd/lineales:pop-back-quitar-atras}}
Elimina el √∫ltimo valor del vector.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// En este caso, elimina el 1}
    \PYG{n}{vec}\PYG{p}{.}\PYG{n}{pop\PYGZus{}back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{insert (insertar)}
\label{\detokenize{edd/lineales:insert-insertar}}
Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que est√©n m√°s adelante, lo que es lento.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Inserta el valor 4 al √≠ndice 2}
    \PYG{n}{vec}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{erase (borrar)}
\label{\detokenize{edd/lineales:erase-borrar}}
Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Elimina el valor con √≠ndice 2}
    \PYG{c+c1}{// En nuestro caso, el 4 que insertamos antes.}
    \PYG{n}{vec}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Iteradores de un arreglo}
\label{\detokenize{edd/lineales:iteradores-de-un-arreglo}}
Hay ciertos iteradores que podemos usar en un arreglo que nos ayudar√°n en algunos casos, como por ejemplo si quieremos recorrer un arreglo. Estos son:
\begin{itemize}
\item {} 
begin() \textendash{} Iterador que accede al primer valor del arreglo.

\item {} 
end() \textendash{} Accede al final del arreglo.

\item {} 
rbegin() \textendash{} Accede al ultimo elemento del arreglo

\item {} 
rend \textendash{} Accede al inicio del arreglo

\end{itemize}


\subsection{Stacks (pilas)}
\label{\detokenize{edd/lineales:stacks-pilas}}
La pila es una estructura de datos lineal al que s√≥lo puedes acceder al √∫ltimo elemento que fue insertado. Imagina una pila de platos, por ejemplo.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{stack} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{n}{pilita}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{push (empujar)}
\label{\detokenize{edd/lineales:push-empujar}}
Empuja un dato a la cima de la pila.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Empuja un 8 a la cima de la pila.}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{top (cima)}
\label{\detokenize{edd/lineales:top-cima}}
Lee lo que hay en la cima de la pila.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Siguiendo el ejemplo anterior}
    \PYG{c+c1}{// Esto retorna 8}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{pop (quitar)}
\label{\detokenize{edd/lineales:pop-quitar}}
Remueve el dato de la cima de la pila.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Siguiendo el ejemplo anterior}
    \PYG{c+c1}{// Remueve el 8}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{empty (vac√≠o)}
\label{\detokenize{edd/lineales:empty-vacio}}
Retorna 1 si la pila est√° vac√≠a, de lo contrario retorna 0.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 1 ya que nuestra pila est√° vac√≠a.}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{size (tama√±o)}
\label{\detokenize{edd/lineales:size-tamano}}
Retorna el tama√±o de nuestra pila.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 0 ya que nuestra pila no tiene datos.}
    \PYG{n}{pilita}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Queues (colas)}
\label{\detokenize{edd/lineales:queues-colas}}
La cola es una estructura de datos lineal al que s√≥lo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{queue} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{n}{colita}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{push (empujar)}
\label{\detokenize{edd/lineales:id1}}
A√±ade un dato al final de la cola.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{front (frente)}
\label{\detokenize{edd/lineales:front-frente}}
Lee el dato que est√° al frente de la cola.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Siguiendo el ejemplo construido antes}
    \PYG{c+c1}{// Retorna 5, ya que fue lo primero que empujamos a la cola}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{front}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{pop (quitar)}
\label{\detokenize{edd/lineales:id2}}
Remueve el dato que est√° al frente de la cola

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Remueve el 5}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora est√° primero).}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{front}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{empty (vac√≠o)}
\label{\detokenize{edd/lineales:id3}}
Retorna 1 si la cola est√° vac√≠a, de lo contrario retorna 0.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 1 ya que nuestra cola est√° vac√≠a.}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{size (tama√±o)}
\label{\detokenize{edd/lineales:id4}}
Retorna el tama√±o de nuestra cola.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna 0 ya que nuestra cola no tiene datos.}
    \PYG{n}{colita}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Estructuras de Datos No Lineales}
\label{\detokenize{edd/no_lineales:estructuras-de-datos-no-lineales}}\label{\detokenize{edd/no_lineales::doc}}

\subsection{Acerca de}
\label{\detokenize{edd/no_lineales:acerca-de}}
A diferencia de las EDD lineales, las no lineales se basan en el hecho de que ahora los elementos no estan contiguos, sino que la forma de buscarlos sigue alguna otra l√≥gica que no sea mirar el siguiente.

Algunos ejemplos son:
\begin{itemize}
\item {} 
√Årboles binarios

\item {} 
Tablas de hashing

\end{itemize}


\subsection{Set (conjunto)}
\label{\detokenize{edd/no_lineales:set-conjunto}}
Es una EDD que consiste en organizar elementos no repetidos. Esto quiere decir que cada elemento va a encontrar una y una sola vez en el conjunto.


\subsubsection{Inicializaci√≥n}
\label{\detokenize{edd/no_lineales:inicializacion}}
Incluimos la librer√≠a:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}set\PYGZgt{}}
\end{sphinxVerbatim}

Inicializamos nuestro conjunto:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{set} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{n}{conjunto}\PYG{p}{;} \PYG{c+c1}{// int puede ser reemplazado con cualquier otro tipo de dato}
\end{sphinxVerbatim}


\subsubsection{insert (Insertar)}
\label{\detokenize{edd/no_lineales:insert-insertar}}
Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya exist√≠a o no. En el ejemplo de abajo, usamos .second para comprobar si se insert√≥ correctamente o no.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Retorna TRUE ya que no estaba anteriormente}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{.}\PYG{n}{second}\PYG{p}{)}
            \PYG{c+c1}{// Retorna FALSE ya que ya hab√≠a un 10.}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ganai}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;} \PYG{k}{if} \PYG{p}{(}\PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{.}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{no ganai}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{find (Encontrar)}
\label{\detokenize{edd/no_lineales:find-encontrar}}
Busca un elemento en el set y si lo encuentra retorna un iterador al valor. De lo contrario, retorna conjunto.end();

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ganai}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{erase (borrar)}
\label{\detokenize{edd/no_lineales:erase-borrar}}
Puedes borrar un valor si le entregas el iterador al valor.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{set} \PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}}\PYG{p}{.}\PYG{p}{.} \PYG{n}{code}\PYG{o}{:}\PYG{o}{:} \PYG{n+nl}{cpp}
\PYG{p}{:}\PYG{n}{number}\PYG{o}{\PYGZhy{}}\PYG{n+nl}{lines}\PYG{p}{:} \PYG{n}{iterator} \PYG{n}{it} \PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Iterar a trav√©s de un conjunto}
\label{\detokenize{edd/no_lineales:iterar-a-traves-de-un-conjunto}}
Puedes iterar a trav√©s de un conjunto con los valores ya ordenados con un iterador:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Imprime 10 11 20 30 40}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{conjunto}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{it}\PYG{p}{)}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{it} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Map (mapa, tabla de hashing)}
\label{\detokenize{edd/no_lineales:map-mapa-tabla-de-hashing}}
Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logar√≠tmico con la implementaci√≥n de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.


\subsubsection{Ejemplo cotidiano}
\label{\detokenize{edd/no_lineales:ejemplo-cotidiano}}\begin{itemize}
\item {} 
Libros:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
T√≠tulo (Llave)
&\sphinxstyletheadfamily 
Autor (Valor)
\\
\hline
The C Programming Language
&
Brian Keringhan
\\
\hline
The AWK Programming Language
&
Brian Keringhan
\\
\hline
1984
&
George Orwell
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\item {} 
Curso:
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Apellido
&\sphinxstyletheadfamily 
Cantidad de alumnos con el apellido
\\
\hline
Gonzalez
&
3
\\
\hline
Perez
&
2
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\end{itemize}


\subsubsection{Inicializar \{\#inicializar\}}
\label{\detokenize{edd/no_lineales:inicializar-inicializar}}
Incluimos la librer√≠a de map:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}map\PYGZgt{}}
\end{sphinxVerbatim}

Inicializamos el mapa curso:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{curso}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Insert (insertar)}
\label{\detokenize{edd/no_lineales:id1}}\begin{itemize}
\item {} 
Forma 1:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{curso}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{perez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Forma 2:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{curso}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gonzalez, 3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Operar con los valores}
\label{\detokenize{edd/no_lineales:operar-con-los-valores}}
Se puede operar con el valor tomando la llave.
Ejemplo 1:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+c1}{// Incrementar el valor de la llave perez, por ejemplo.}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{curso}\PYG{p}{.}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{perez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Ejemplo 2:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{curso}\PYG{p}{.}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{perez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;} \PYG{c+c1}{// El output ser√° 2.}
\end{sphinxVerbatim}

Cuidado con operar con valores no existentes, pues los inicializar√° de una forma inesperada.


\subsubsection{Find (encontrar)}
\label{\detokenize{edd/no_lineales:id2}}
Retorna un iterador, si no lo encuentra, apunta a map.end().
Asignamos el iterador \sphinxcode{\sphinxupquote{it}} a gonzalez, y luego lo usamos:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{map}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{.}\PYG{p}{.} \PYG{n}{code}\PYG{o}{:}\PYG{o}{:} \PYG{n+nl}{cpp}
\PYG{p}{:}\PYG{n}{number}\PYG{o}{\PYGZhy{}}\PYG{n+nl}{lines}\PYG{p}{:} \PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
    \PYG{n}{it} \PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gonzalez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hay }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{first} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ en el curso:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Llave: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{first} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Valor: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Podemos incluso operar usando los iteradores:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{o}{+}\PYG{o}{+}\PYG{n}{second}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Erase (borrar)}
\label{\detokenize{edd/no_lineales:id3}}\begin{itemize}
\item {} 
Forma 1:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{it} \PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{perez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{curso}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{it}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Forma 2:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{n}{curso}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gonzalez}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Recorrer los valores de un mapa}
\label{\detokenize{edd/no_lineales:recorrer-los-valores-de-un-mapa}}
Es exactamente igual que en un conjunto:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{curso}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{it}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Llave: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{first} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Valor: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZbs{}n}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Dudas que no dejan dormir}
\label{\detokenize{edd/no_lineales:dudas-que-no-dejan-dormir}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
¬øQu√© pasa si modifico una llave?

\end{enumerate}

No se puede, tu c√≥digo no compilar√° pues es ilegal hacerlo üëÆüöìüö®
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
¬øPuedo buscar con el second?

\end{enumerate}

No, en ese caso recomendamos otra estructura, o tener dos maps üëÄ
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
¬øPuedo tener un map dentro de un map?

\end{enumerate}

Si, pero es de psic√≥pata buscar dentro de ese map.


\chapter{Algoritmos de Ordenamiento}
\label{\detokenize{ordenamiento/ordenamiento:algoritmos-de-ordenamiento}}\label{\detokenize{ordenamiento/ordenamiento::doc}}
Uno de los problemas m√°s cl√°sicos de la inform√°tica es el problema de ordenamiento, este corresponde a tomo un grupo de datos y los ordenan a base de alg√∫n criterio. Hay muchos algoritmos actualmente, vamos a revisar en detalle tres algoritmos. Dos que corresponden a algoritmos que siguen la t√©cnica de fuerza bruta y uno que consiste a decrecer y conquistar. Estos si bien no son los algoritmos m√°s eficientes, son muy √∫tiles para entende la base del ordenamiento.


\section{Algoritmos de Fuerza Bruta}
\label{\detokenize{ordenamiento/fuerza_bruta:algoritmos-de-fuerza-bruta}}\label{\detokenize{ordenamiento/fuerza_bruta::doc}}

\subsection{Acerca de}
\label{\detokenize{ordenamiento/fuerza_bruta:acerca-de}}
Los algoritmos de fuerza bruta son algoritmo en general simples, que realizan una idea de ‚Äú‚ÄùTodos con todos‚Äù‚Äù. Esto puede llegar a ser muy costoso en complejidad.


\subsection{Bubble sort}
\label{\detokenize{ordenamiento/fuerza_bruta:bubble-sort}}\begin{itemize}
\item {} 
Se van comparando los elementos, haciendo que los m√°s grandes suban en el arreglo, como una burbuja.

\item {} 
Da lo mismo c√≥mo est√©n ordenadas las cosas, porque puedes modificar la funci√≥n de comparaci√≥n.

\item {} 
Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo.

\item {} 
Por ejemplo, se podr√≠a usar para contar el n√∫mero de inversiones que hay que hacer.

\end{itemize}


\subsubsection{Ejemplo}
\label{\detokenize{ordenamiento/fuerza_bruta:ejemplo}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Step
&
Pos 0
&
Pos 1
&
Pos 2
&
Pos 3
\\
\hline
0
&
5
&
3
&
4
&
1
\\
\hline
1
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{3}
&
4
&
1
\\
\hline
2
&
3
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{4}
&
1
\\
\hline
3
&
3
&
4
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{1}
\\
\hline
4
&
3
&
4
&
1
&
\sphinxstylestrong{5}
\\
\hline
5
&
\sphinxstyleemphasis{3}
&
\sphinxstyleemphasis{4}
&
1
&
\sphinxstylestrong{5}
\\
\hline
6
&
3
&
\sphinxstyleemphasis{1}
&
\sphinxstyleemphasis{4}
&
\sphinxstylestrong{5}
\\
\hline
7
&
3
&
1
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
8
&
\sphinxstyleemphasis{3}
&
\sphinxstyleemphasis{1}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
9
&
1
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
10
&
\sphinxstylestrong{1}
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsubsection{C√≥digo}
\label{\detokenize{ordenamiento/fuerza_bruta:codigo}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{aux} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aux}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{bubblesort} \PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Insertion sort}
\label{\detokenize{ordenamiento/fuerza_bruta:insertion-sort}}\begin{itemize}
\item {} 
Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y as√≠ hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.

\end{itemize}


\subsubsection{Ejemplo}
\label{\detokenize{ordenamiento/fuerza_bruta:id1}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Step
&
Pos 0
&
Pos 1
&
Pos 2
&
Pos 3
\\
\hline
0
&
5
&
3
&
4
&
1
\\
\hline
1
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{3}
&
4
&
1
\\
\hline
2
&
\sphinxstylestrong{3}
&
5
&
4
&
1
\\
\hline
3
&
3
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{4}
&
1
\\
\hline
4
&
\sphinxstyleemphasis{3}
&
\sphinxstyleemphasis{4}
&
5
&
1
\\
\hline
5
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
5
&
1
\\
\hline
6
&
3
&
4
&
\sphinxstyleemphasis{5}
&
\sphinxstyleemphasis{1}
\\
\hline
7
&
3
&
\sphinxstyleemphasis{4}
&
\sphinxstyleemphasis{1}
&
5
\\
\hline
8
&
\sphinxstyleemphasis{3}
&
\sphinxstyleemphasis{1}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
9
&
\sphinxstylestrong{1}
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsubsection{C√≥digo}
\label{\detokenize{ordenamiento/fuerza_bruta:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{aux} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{aux}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{insertion\PYGZus{}sort}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{arr}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{c+c1}{//caso swap}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
              \PYG{n}{swap}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{j}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{//caso no swap = todo ok todo correcto :]}
            \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{j}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]} \PYG{o}{|}\PYG{o}{|} \PYG{n}{j} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Nota: este c√≥digo fue robado de Julieta Coloma}


\section{Algoritmos de Decrecer y Conquistar}
\label{\detokenize{ordenamiento/dec_conq:algoritmos-de-decrecer-y-conquistar}}\label{\detokenize{ordenamiento/dec_conq::doc}}

\subsection{Acerca de}
\label{\detokenize{ordenamiento/dec_conq:acerca-de}}
Rellenar


\subsection{Selection sort}
\label{\detokenize{ordenamiento/dec_conq:selection-sort}}\begin{itemize}
\item {} 
Tiene dos sub\sphinxhyphen{}arreglos, uno de elementos ya ordenados y uno de los elementos resantes.

\item {} 
El arreglo ya ordenado parte vac√≠o.

\item {} 
Busca el valor m√≠nimo entre los elementos no ordenados y lo a√±ade al final de los ordenados.

\end{itemize}


\subsubsection{Ejemplo}
\label{\detokenize{ordenamiento/dec_conq:ejemplo}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline

Step
&
Pos 0
&
Pos 1
&
Pos 2
&
Pos 3
\\
\hline
0
&
5
&
3
&
4
&
1
\\
\hline
1
&
5
&
3
&
4
&
\sphinxstyleemphasis{1}
\\
\hline
2
&
\sphinxstylestrong{1}
&
5
&
\sphinxstyleemphasis{3}
&
4
\\
\hline
3
&
\sphinxstylestrong{1}
&
\sphinxstylestrong{3}
&
5
&
\sphinxstyleemphasis{4}
\\
\hline
4
&
\sphinxstylestrong{1}
&
\sphinxstylestrong{3}
&
\sphinxstylestrong{4}
&
\sphinxstylestrong{5}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsubsection{C√≥digo de ejemplo}
\label{\detokenize{ordenamiento/dec_conq:codigo-de-ejemplo}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k+kt}{void} \PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{aux} \PYG{o}{=} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{vec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=} \PYG{n}{aux}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{void} \PYG{n+nf}{selectionSort}\PYG{p}{(}\PYG{n}{vector} \PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//tama√±o :D}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//}
                    \PYG{k+kt}{int} \PYG{n}{min\PYGZus{}in} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j}\PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{size}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                            \PYG{k}{if}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{vec}\PYG{p}{[}\PYG{n}{min\PYGZus{}in}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                                    \PYG{n}{min\PYGZus{}in}\PYG{o}{=}\PYG{n}{j}\PYG{p}{;}
                            \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{swap}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{,} \PYG{n}{min\PYGZus{}in}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{Nota: este c√≥digo fue robado de Natalia Carri√≥n}


\chapter{Algoritmos de b√∫squeda}
\label{\detokenize{busqueda/busqueda:algoritmos-de-busqueda}}\label{\detokenize{busqueda/busqueda::doc}}
Otro problema muy recurrente dentro de la programaci√≥n es el buscar uno o m√°s elementos dentro de un grupo de datos. Para ello se han desarrollado varios algoritmos de tal forma de optimizar esta busqueda.

Los dos principales y m√°s nombrados son la b√∫squeda lineal y binaria. Estas dos b√∫squedas se detallar√°n para comprender su uso y benificio.


\section{B√∫squeda Lineal}
\label{\detokenize{busqueda/lineal:busqueda-lineal}}\label{\detokenize{busqueda/lineal::doc}}

\subsection{Acerca de}
\label{\detokenize{busqueda/lineal:acerca-de}}
La b√∫squeda lineal es un algoritmo se trata de pasar elemento por elemento hasta encontrar el correcto. Esto lo hace de forma secuencial, de ah√≠ el nombre lineal.

Entonces analizando, si uno tiene \sphinxstylestrong{N} elementos toma un elemento y ve si es el correcto. Si corresponde listo ganamos, si no pasa al siguiente. Esto lo repite hasta el √∫ltimo elemento.

Este algoritmo tiene complejidad \sphinxstylestrong{O(N)}. La principal gracia de este algoritmo es cuando el grupo de elementos no est√°n ordenados por lo cual uno no sabr√≠a como moverse. En la siguiente secci√≥n se revisar√° un algoritmo para cuando el grupo este ordenado.


\subsection{Ejemplo}
\label{\detokenize{busqueda/lineal:ejemplo}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline

Step
&
Pos 0
&
Pos 1
&
Pos 2
&
Pos 3
&
Ele
\\
\hline
0
&
4
&
2
&
5
&
1
&
5
\\
\hline
1
&
\sphinxstylestrong{4}
&
2
&
5
&
1
&
5
\\
\hline
2
&
4
&
\sphinxstylestrong{2}
&
5
&
1
&
5
\\
\hline
3
&
4
&
2
&
\sphinxstylestrong{5}
&
1
&
5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

Aqu√≠ se ve como en la iteraci√≥n n√∫mero 3 encuentra el elemento por lo deja de revisar :D.


\subsection{C√≥digo}
\label{\detokenize{busqueda/lineal:codigo}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{linealSearch}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ele}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{vec}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ele}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Retorna la posicion en que se encuentra}
                    \PYG{k}{return} \PYG{n}{i}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Retorna \PYGZhy{}1 en caso de que el elemento no este}
    \PYG{k}{return} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{B√∫squeda Binaria}
\label{\detokenize{busqueda/binaria:busqueda-binaria}}\label{\detokenize{busqueda/binaria::doc}}

\subsection{Acerca de}
\label{\detokenize{busqueda/binaria:acerca-de}}
La b√∫squeda binaria es un algoritmo de \sphinxstyleemphasis{divide and conquer} (dividir y
conquistar), que nos permite encontrar un elemento dentro de una
estructura \sphinxstylestrong{ordenada} r√°pidamente. Al ejecutarse, toma el centro de un
arreglo y comprueba si el valor que se busca es igual al del centro. De
no serlo, verifica si el valor es menor o mayor al del centro.

Si el valor es mayor al del centro, se ignoran todos los valores
anteriores al centro, dividiendo la cantidad de n√∫meros a la mitad.

Si el valor es menor al del centro, se ignoran todos los valores de
despu√©s del centro, dividiendo la cantidad de n√∫meros a la mitad.

La complejidad de este algoritmo es \sphinxstylestrong{O(log(N))}, comparada con un
algoritmo lineal, que en el peor de los casos tiene complejidad
\sphinxstylestrong{O(N)}.

Pero hay que notar que para aplicar este algoritmo uno debe tener el grupo ordenado, debido a que si no esta ordenado no hay forma de poder saber hacia donde moverse seg√∫n la respuesta dada a la comparaci√≥n.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ejemplos
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
en la vida real
\begin{quote}

Ir al medio de un diccionario, y buscar alfab√©ticamente, tomando
una palabra central (m√°s o menos), viendo si la palabra que
queremos est√° antes o despu√©s y repetir el proceso de buscar una
palabra central.
\end{quote}

\item {} 
Ejemplo computacional
\begin{quote}

En esta im√°gen, se usa la b√∫squeda binaria para encontrar el 19.
\sphinxincludegraphics{{f0801}.png}
\end{quote}

\end{enumerate}

\end{enumerate}


\subsection{Uso mediante la librer√≠a STL}
\label{\detokenize{busqueda/binaria:uso-mediante-la-libreria-stl}}\begin{itemize}
\item {} 
Importar
\begin{quote}

Podemos directamente importar toda la stl o podemos importar la
librer√≠a \textless{}algorithm\textgreater{} de la siguiente forma:
\end{quote}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
binary\_search()
\begin{quote}

La librer√≠a STL ya incluye binary search, si queremos saber si el valor 3 est√° en un vector, podemos ejecutar:
\end{quote}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{binary\PYGZus{}search} \PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Se encuentra el valor 3 en nuestro vector}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{p}{\PYGZob{}}
  \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{No hay ning√∫n 3 en nuestro vector}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Retorna un \sphinxstyleemphasis{bool}.
\begin{itemize}
\item {} 
lower\_bound() (l√≠mite inferior)
\begin{quote}

La funci√≥n lower\_bound() de la librer√≠a STL retorna un puntero a un valor \sphinxstylestrong{superior} o, si es posible, \sphinxstylestrong{igual} al entregado dentro de una estructura ordenada.

Si todos los elementos en el arreglo son inferiores al valor pedido, se entrega el √∫ltimo elemento del arreglo. Si los elementos del arreglo son superiores al valor pedido, se entrega el primer elemento del arreglo.

Por ejemplo:
\end{quote}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{\PYGZob{}} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{50} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{o}{*}\PYG{n}{lower\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Valor de retorno: un iterador que apunta hacia \sphinxstylestrong{30} (el primero en el arreglo, en la posici√≥n {[}2{]})
\begin{itemize}
\item {} 
upper\_bound() (l√≠mite superior)
\begin{quote}

La funci√≥n upper$_{\text{bound}}$() de la librer√≠a STL nos entrega un puntero a un valor \sphinxstylestrong{superior} al pedido en un arreglo ordenado.

En el caso de que no haya un valor superior al pedido, nos entrega el √∫ltimo valor del arreglo.

Por ejemplo:
\end{quote}

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{o}{*}\PYG{n}{upper\PYGZus{}bound}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Valor de retorno: iterador al \sphinxstylestrong{40} (posici√≥n {[}4{]})


\subsection{Implementaciones propias}
\label{\detokenize{busqueda/binaria:implementaciones-propias}}

\subsubsection{Implementaci√≥n con while}
\label{\detokenize{busqueda/binaria:implementacion-con-while}}\begin{quote}

Esta implementaci√≥n nos retorna el √≠ndice del n√∫mero a buscar dentro de un arreglo.
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{binarySearch}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{r}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{k}{while} \PYG{p}{(}\PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{r}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Esto es lo mismo que hacer (r + l) / 2}
        \PYG{k+kt}{int} \PYG{n}{m} \PYG{o}{=} \PYG{n}{l} \PYG{o}{+} \PYG{p}{(}\PYG{n}{r} \PYG{o}{\PYGZhy{}} \PYG{n}{l}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}

        \PYG{c+c1}{// Revisa si x esta al medio}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{m}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// Si x es mayor, ignorar la izquierda}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{l} \PYG{o}{=} \PYG{n}{m} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Si x es menor, ignorar la derecha}
        \PYG{k}{else}\PYG{p}{\PYGZob{}}
            \PYG{n}{r} \PYG{o}{=} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Implementaci√≥n recursiva}
\label{\detokenize{busqueda/binaria:implementacion-recursiva}}\begin{quote}

Esta implementaci√≥n nos retorna el √≠ndice del n√∫mero a buscar dentro de un arreglo.
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{binarySearch}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{arr}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{l}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{r}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{r} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Esto es lo mismo que hacer (r + l) / 2}
        \PYG{k+kt}{int} \PYG{n}{mid} \PYG{o}{=} \PYG{n}{l} \PYG{o}{+} \PYG{p}{(}\PYG{n}{r} \PYG{o}{\PYGZhy{}} \PYG{n}{l}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{;}

        \PYG{c+c1}{// Revisa si x esta al medio}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{mid}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// Si x es mayor, ignorar la izquierda}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{x}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{binarySearch}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{l}\PYG{p}{,} \PYG{n}{mid} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{// Si x es mayor, ignorar la derecha}
        \PYG{k}{return} \PYG{n}{binarySearch}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{,} \PYG{n}{mid} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}



\renewcommand{\indexname}{√çndice}
\printindex
\end{document}