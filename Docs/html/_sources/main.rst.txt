Estructuras de datos
====================

Estructuras lineales
--------------------

Acerca de
~~~~~~~~~

Rellenar página

Arrays (arreglos)
~~~~~~~~~~~~~~~~~

Los arrays son conjuntos de datos que se almacenan en memoria de manera
contigua usando el mismo nombre. Se usan índices para diferenciar los
distintos valores del arreglo. Para crear una arreglo es necesario saber
la cantidad de elementos que van a componer nuestro arreglo, pues la
cantidad de elementos no se puede cambiar. Una cosa muy importante que
al principio uno suele olvidar es que los índices de los arreglos parten
en 0. Es decir, un arreglo de tamaño n puede tomar índices desde el 0
hasta el n-1.

#. Inicialización

   Hay dos formas de inicializar un array, especificando su tamaño o
   llenandolo con valores por defecto.

   #. Inicializar un array por su tamaño

      Para inicializar un array por su tamaño, lo único que hay que
      especificar es el nombre de la variable y colocar entre "[]" el
      tamaño de nuestro arreglo. Recordar que como los arrays parten en
      0, el valor máximo que podremos acceder será el tamaño del array
      menos 1.

      .. code:: cpp
         :number-lines:

         int arreglo[38]; // Inicializar un arreglo de ints de tamaño 38.

   #. Inicializar un array con valores por defecto

      Para inicializar un array con valores por defecto, no es necesario
      especificar el tamaño de nuestro array, pues este está implícito
      en la cantidad de valores que introducimos.

      .. code:: cpp
         :number-lines:

         int arreglo2[] = {3, 6, 2, 1};

#. Leer el valor de un arreglo

   Para leer un valor de nuestro arreglo, solo hay que especificar el
   nombre del arreglo y su índice. Notar que sólo se puede acceder a un
   valor de un arreglo a la vez.

   .. code:: cpp

      arreglo2[3]; // Retorna 1

#. Asignar valores a un arreglo

   Para esto, hay que especificar la variable, el índice al cuál acceder
   y especificar su nuevo valor. Recordar que el valor del índice puede
   ser una variable, pero que no puede estar fuera del rango del tamaño
   de nuestro arreglo.

   .. code:: cpp
      :number-lines:

      arreglo2[3] = 5; // El indice 3 de nuestro arreglo, ahora tiene el valor 3

Arrays multidimensionales
~~~~~~~~~~~~~~~~~~~~~~~~~

Un array multidimensional es aquel que requiuere de más de un índice
para ser llamado, como su nombre lo indica, es útil para cuando
necesitamos acceder a datos que requieren más de una dimensión, como por
ejemplo valores dentro de una malla. Otra forma de enternder los arrays
multidimensionales es como un arreglo de arreglos (de arreglos de
arreglos.. n veces, siendo n la cantidad de dimensiones). Los arreglos
de 2 dimensiones también son conocidos como matrices.

#. Inicializar un arreglo multidimensional

   Para esto, hay que especificar el tamaño de cada dimensión del array.
   Notar que la regla de que empiezan en 0 y terminan en n-1 se sigue
   cumpliendo. Es posible asignarles valores predeterminados, pero creo
   que eso se va poniendo exponencialmente más psicópata a medida de que
   vas incrementando las dimensiones del array a crear, por lo que no lo
   voy a demostrar.

   .. code:: cpp
      :number-lines:

      int matriz[3][4];
      int tridimensional[100][100][100];

#. Asignar valores en un arreglo multidimensional

   Es muy similar a cómo se hace en un arreglo unidimensional, solo que
   se especifica cada índice.

   .. code:: cpp
      :number-lines:

      int n = 3, m = 5;
      matriz[2][1] = 10;
      tridimensional[n][m] = 4;

Vectors (vectores)
~~~~~~~~~~~~~~~~~~

Los vectores son como arreglos, excepto de que el tamaño es dinámico, es
decir, se puede cambiar.

#. Inicializar un vector

   Incluimos la librería:

   .. code:: cpp
      :number-lines:

      #include <vector>

   Inicializamos nuestro vector "vec":

   .. code:: cpp
      :number-lines:

      int n = 3;
      vector < int > vec(n, 0); // Inicializa un vector de tamaño 3 con todos sus valores = 0. Tanto el tamaño como valor son opcionales.

#. Asignar un valor

   .. code:: cpp
      :number-lines:

      vec[2] = 1; // Asigna el valor "1" al índice 2 (es decir, al 3er valor del vector)

#. push back (empujar atrás)

   Si no sabemos el tamaño de nuestro vector, podemos simplemente usar
   push\ :sub:`back`\ (valor); para enviar es valor al final del vector.

   .. code:: cpp
      :number-lines:

      vec.push_back(1); // Inserta un 1 al final del vector

   Por ejemplo, se podría usar en un for, sin necesidad de inicializar
   el vector con una cantidad de valores.

   .. code:: cpp
      :number-lines:

      vector <int> vec2;
      int n;
      cin >> n;
      for (int i = 0; i < n; ++i){
          int valor;
          cin >> valor;
          vec2.push_back();
      }

#. pop back (quitar atrás)

   Elimina el último valor del vector.

   .. code:: cpp
      :number-lines:

      vec.pop_back(); // En este caso, elimina el 1

#. insert (insertar)

   Podemos insertar un valor entre dos indices de un vector. El problema
   de esto es que mueve todos los valores que estén más adelante, lo que
   es lento.

   .. code:: cpp
      :number-lines:

      vec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al índice 2

#. erase (borrar)

   Borra un dato del vector. Al igual que el insert, tiene que mover
   todos los datos siguientes (esta vez a la derecha).

   .. code:: cpp
      :number-lines:

      vec.erase(vec.begin() + 2); // Elimina el valor con índice 2, en nuestro caso, el 4 que insertamos antes.

#. Iteradores de un arreglo

   Hay ciertos iteradores que podemos usar en un arreglo que nos
   ayudarán en algunos casos, como por ejemplo si quieremos recorrer un
   arreglo. Estos son:

   -  begin() – Iterador que accede al primer valor del arreglo.
   -  end() – Accede al final del arreglo.
   -  rbegin() – Accede al ultimo elemento del arreglo
   -  rend – Accede al inicio del arreglo

Stacks (pilas)
~~~~~~~~~~~~~~

La pila es una estructura de datos lineal al que sólo puedes acceder al
último elemento que fue insertado. Imagina una pila de platos, por
ejemplo.

.. code:: cpp
   :number-lines:

   stack < int > pilita;

#. push (empujar)

   Empuja un dato a la cima de la pila.

   .. code:: cpp
      :number-lines:

      pilita.push(8); // Empuja un 8 a la cima de la pila.

#. top (cima)

   Lee lo que hay en la cima de la pila.

   .. code:: cpp
      :number-lines:

      pilita.top(); // Retorna el 8.

#. pop (quitar)

   Remueve el dato de la cima de la pila.

   .. code:: cpp
      :number-lines:

      pilita.pop(); // Remueve el 8.

#. empty (vacío)

   Retorna 1 si la pila está vacía, de lo contrario retorna 0.

   .. code:: cpp
      :number-lines:

      pilita.empty(); // Retorna 1 ya que nuestra pila está vacía.

#. size (tamaño)

   Retorna el tamaño de nuestra pila.

   .. code:: cpp
      :number-lines:

      pilita.size(); // Retorna 0 ya que nuestra pila no tiene datos.

Queues (colas)
~~~~~~~~~~~~~~

La cola es una estructura de datos lineal al que sólo puedes acceder al
primer elemento que fue insertado. Imagina una fila de una caja de un
supermercado, por ejemplo.

.. code:: cpp
   :number-lines:

   queue < int > colita;

#. push (empujar)

   Añade un dato al final de la cola.

   .. code:: cpp
      :number-lines:

      colita.push(5);
      colita.push(4);
      colita.push(3);
      colita.push(2);
      colita.push(1);

#. front (frente)

   Lee el dato que está al frente de la cola.

   .. code:: cpp
      :number-lines:

      colita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola.

#. pop (quitar)

   Remueve el dato que está al frente de la cola

   .. code:: cpp
      :number-lines:

      colita.pop();   // Remueve el 5
      colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora está primero).

#. empty (vacío)

   Retorna 1 si la cola está vacía, de lo contrario retorna 0.

   .. code:: cpp
      :number-lines:

      colita.empty(); // Retorna 1 ya que nuestra cola está vacía.

#. size (tamaño)

   Retorna el tamaño de nuestra cola.

   .. code:: cpp
      :number-lines:

      colita.size(); // Retorna 0 ya que nuestra cola no tiene datos.

Estructuras en forma de árbol
-----------------------------

.. _acerca-de-1:

Acerca de
~~~~~~~~~

Véase: arbol binario

Set (conjunto)
~~~~~~~~~~~~~~

Es una lista que no permite que hayan elementos repetidos.

#. Inicialización

   Incluimos la librería:

   .. code:: cpp
      :number-lines:

      #include <set>

   Inicializamos nuestro conjunto:

   .. code:: cpp
      :number-lines:

      set < int > conjunto; // int puede ser reemplazado con cualquier otro tipo de dato

#. insert (Insertar)

   Inserta un dato. Retorna un par de elementos, el primero siendo el
   iterador del valor insertado y el segundo siendo un bool que marca si
   es que ya existía o no. En el ejemplo de abajo, usamos .second para
   comprobar si se insertó correctamente o no.

   .. code:: cpp
      :number-lines:

      if (conjunto.insert(10).second) // Retorna TRUE ya que no estaba anteriormente
          cout << "ganai\n"; if (conjunto.insert(10).second); // Retorna FALSE ya que ya había un 10.
      cout << "no ganai\n";
      conjunto.insert(20);
      conjunto.insert(40);
      conjunto.insert(30);
      conjunto.insert(11);

#. find (Encontrar)

   Busca un elemento en el set y si lo encuentra retorna un iterador al
   valor. De lo contrario, retorna conjunto.end();

   .. code:: cpp
      :number-lines:

      if (conjunto.find(10) != conjunto.end())
          cout << "ganai\n";

#. erase (borrar)

   Puedes borrar un valor si le entregas el iterador al valor.

   .. code:: cpp
      :number-lines:

      set < int >::iterator it = conjunto.find(11);
      if (it != conjunto.end())
          conjunto.erase(it);

#. Iterar a través de un conjunto

   Puedes iterar a través de un conjunto con los valores ya ordenados
   con un iterador:

   .. code:: cpp
      :number-lines:

      // Imprime 10 11 20 30 40
      for (it = conjunto.begin(); it != conjunto.end(); ++it)
          cout << *it << " ";
      cout << '\n';

Map (mapa, tabla de hashing)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo
logarítmico con la implementación de la STL. Pero con otras
implementaciones se puede hacer en tiempo constante. Las llaves no se
pueden repetir.

#. Ejemplo cotidiano

   Libros:

   ============================ ===============
   Título (Llave)               Autor (Valor)
   ============================ ===============
   The C Programming Language   Brian Keringhan
   The AWK Programming Language Brian Keringhan
   1984                         George Orwell
   ============================ ===============

   Curso:

   ======== ===================================
   Apellido Cantidad de alumnos con el apellido
   ======== ===================================
   Gonzalez 3
   Perez    2
   ======== ===================================

#. Inicializar

   Incluimos la librería de map:

   .. code:: cpp
      :number-lines:

      #include <map>

   Inicializamos el mapa curso:

   .. code:: cpp
      :number-lines:

      map<string, int> curso;

#. Insert (insertar)

   Forma 1:

   .. code:: cpp
      :number-lines:

      curso["perez"] = 1;

   Forma 2:

   .. code:: cpp
      :number-lines:

      curso.insert(pair<string, int>("gonzalez, 3"));

#. Operar con los valores

   Se puede operar con el valor tomando la llave. Ejemplo 1:

   .. code:: cpp
      :number-lines:

      ++curso.["perez"]; // Incrementar el valor de la llave perez, por ejemplo.

   Ejemplo 2:

   .. code:: cpp
      :number-lines:

      cout << curso.["perez"] << endl; // El output será 2.

   Cuidado con operar con valores no existentes, pues los inicializará
   de una forma inesperada.

#. Find (encontrar)

   Retorna un iterador, si no lo encuentra, apunta a map.end() Asignamos
   el iterador it a gonzalez, y luego lo usamos:

   .. code:: cpp
      :number-lines:

      map<string, int>::iterator it;
      it = curso.find("gonzalez");

      if (it != curso.end()){
      cout << "Hay " << it->second << " " << it->first << " en el curso:\n";
      cout << "Llave: " << it->first << " Valor: " << it->second << '\n';
      }

   Podemos incluso operar usando los iteradores:

   .. code:: cpp
      :number-lines:

      it->++second;

#. Erase (borrar)

   Forma 1:

   .. code:: cpp
      :number-lines:

      it = curso.find("perez");
      curso.erase(it);

   Forma 2:

   .. code:: cpp
      :number-lines:

      curso.erase("gonzalez");

#. Recorrer los valores de un mapa

   Es exactamente igual que en un conjunto:

   .. code:: cpp
      :number-lines:

      for (it = curso.begin(); it != curso.end(); ++it){
          cout << "Llave: " << it->first << " Valor: " << it->second << '\n';
      }

#. Dudas que no dejan dormir

   #. ¿Qué pasa si modifico una llave?

      No se puede, tu código no compilará pues es ilegal hacerlo 👮🚓🚨

   #. ¿Puedo buscar con el second?

      No, en ese caso recomendamos otra estructura, o tener dos maps 👀

   #. ¿Puedo tener un map dentro de un map?

      Si, pero es de psicópata buscar dentro de ese map.

Algoritmos de ordenamiento
==========================

.. _acerca-de-2:

Acerca de
---------

Un algoritmo de ordenamiento es aquel que toma los elementos de una
estructura y les asigna un orden. Cada algoritmo de ordenamiento tiene
su forma de operar, y podría ayudar a conseguir la respuesta a un
problema, no necesariamente por el resultado del ordenamiento.

Algoritmos de fuerza bruta
--------------------------

.. _acerca-de-3:

Acerca de
~~~~~~~~~

Rellenar

Bubble sort
~~~~~~~~~~~

-  Se van comparando los elementos, haciendo que los más grandes suban
   en el arreglo, como una burbuja.
-  Da lo mismo cómo estén ordenadas las cosas, porque puedes modificar
   la función de comparación.
-  Funciona invirtiendo el orden de cada par de elementos, si es que el
   primero es mayor que el segundo.
-  Por ejemplo, se podría usar para contar el número de inversiones que
   hay que hacer.

#. Ejemplo

   ===== ===== ===== =====
   *5*   *3*   4     1
   3     *5*   *4*   1
   3     4     *5*   *1*
   3     4     1     **5**
   *3*   *4*   1     **5**
   3     *1*   *4*   **5**
   3     1     **4** **5**
   *3*   *1*   **4** **5**
   1     **3** **4** **5**
   **1** **3** **4** **5**
   ===== ===== ===== =====

#. Código de ejemplo:

   .. code:: cpp

      void bubblesort (vector<int> &vec) {
          int size = vec.size();
          for (int i = size-1; i > 0; --i) {
              for (int j = 0; j < i; ++j) {
                  if (vec[j] > vec[j+1]) {
                      int aux = vec[j];
                      vec[j] = vec[j+1];
                      vec[j+1] = aux;
                  }
              }
          }
          return;
      }

Insertion sort
~~~~~~~~~~~~~~

-  Se va de izquierda a derecha, se compara el segundo con el primero,
   se intercambian si el segundo es menor, si este es el caso, se vuelve
   a preguntar si el de la izquierda es menor al de mas a la izquierda y
   así hasta que se encuentre un caso en el que no o se llegue al
   principio del arreglo.

#. Rellenar ejemplo

#. Rellenar codigo de ejemplo

Algoritmos de "decrecer y conquistar"
-------------------------------------

.. _acerca-de-4:

Acerca de
~~~~~~~~~

Rellenar

Selection sort
~~~~~~~~~~~~~~

-  Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los
   elementos resantes.
-  El arreglo ya ordenado parte vacío.
-  Busca el valor mínimo entre los elementos no ordenados y lo añade al
   final de los ordenados.

#. Rellenar ejemplo

#. Rellenar codigo de ejemplo

Algoritmos de búsqueda
======================

Búsqueda binaria
----------------

.. _acerca-de-5:

Acerca de
~~~~~~~~~

La búsqueda binaria es un algoritmo de *divide and conquer* (dividir y
conquistar), que nos permite encontrar un elemento dentro de una
estructura **ordenada** rápidamente. Al ejecutarse, toma el centro de un
arreglo y comprueba si el valor que se busca es igual al del centro. De
no serlo, verifica si el valor es menor o mayor al del centro.

Si el valor es mayor al del centro, se ignoran todos los valores
anteriores al centro, dividiendo la cantidad de números a la mitad.

Si el valor es menor al del centro, se ignoran todos los valores de
después del centro, dividiendo la cantidad de números a la mitad.

La complejidad de este algoritmo es **Olog(N)**, comparada con un
algoritmo lineal, que en el peor de los casos tiene complejidad
**O(N)**.

#. Ejemplos

   #. en la vida real

      Ir al medio de un diccionario, y buscar alfabéticamente, tomando
      una palabra central (más o menos), viendo si la palabra que
      queremos está antes o después y repetir el proceso de buscar una
      palabra central.

   #. Ejemplo computacional

      En esta imágen, se usa la búsqueda binaria para encontrar el 19.
      |image1|

Uso mediante la librería STL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. Importar

   Podemos directamente importar toda la stl o podemos importar la
   librería <algorithm> de la siguiente forma:

   .. code:: cpp
      :number-lines:

      #include <algorithm>

#. binary\ :sub:`search`\ ()

   La librería STL ya incluye binary search, si queremos saber si el
   valor 3 está en un vector, podemos ejecutar:

   .. code:: cpp
      :number-lines:

      vector<int> v{1,2,5,7};
      if (binary_search (v.begin(), v.end(), 3)) {
          cout << "Se encuentra el valor 3 en nuestro vector\n";
      }
      else {
          cout << "No hay ningún 3 en nuestro vector\n";
      }

   Retorna un *bool*.

#. lower\ :sub:`bound`\ () (límite inferior)

   La función lower\ :sub:`bound`\ () de la librería STL retorna un
   puntero a un valor **superior** o, si es posible, **igual** al
   entregado dentro de una estructura ordenada.

   Si todos los elementos en el arreglo son inferiores al valor pedido,
   se entrega el último elemento del arreglo. Si los elementos del
   arreglo son superiores al valor pedido, se entrega el primer elemento
   del arreglo.

   Por ejemplo:

   .. code:: cpp
      :number-lines:

      vector<int> v{ 10, 20, 30, 30, 30, 40, 50 };
      *lower_bound(v.begin(), v.end(), 30);

   Valor de retorno: un iterador que apunta hacia **30** (el primero en
   el arreglo, en la posición [2])

#. upper\ :sub:`bound`\ () (límite superior)

   La función upper\ :sub:`bound`\ () de la librería STL nos entrega un
   puntero a un valor **superior** al pedido en un arreglo ordenado.

   En el caso de que no haya un valor superior al pedido, nos entrega el
   último valor del arreglo.

   Por ejemplo:

   .. code:: cpp
      :number-lines:

      *upper_bound(v.begin(), v.end(), 30);

   Valor de retorno: iterador al **40** (posición [4])

Implementaciones propias
~~~~~~~~~~~~~~~~~~~~~~~~

#. Implementación con while

   Esta implementación nos retorna el índice del número a buscar dentro
   de un arreglo.

   .. code:: cpp
      :number-lines:

      int binarySearch(int arr[], int l, int r, int x)
      {

          while (l <= r) {
              int m = l + (r - l) / 2;

              // Revisa si x esta al medio
              if (arr[m] == x)
              return m;

              // Si x es mayor, ignorar la izquierda
              if (arr[m] < x)
              l = m + 1;

              // Si x es menor, ignorar la derecha
              else
              r = m - 1;

          }
          return -1;

      }

#. Implementación recursiva

   Esta implementación nos retorna el índice del número a buscar dentro
   de un arreglo.

   .. code:: cpp
      :number-lines:

      int binarySearch(int arr[], int l, int r, int x)
      {

          if (r >= l) {

              int mid = l + (r - l) / 2;

              // Revisa si x esta al medio

              if (arr[mid] == x)
              return mid;

              // Si x es mayor, ignorar la izquierda
              if (arr[mid] > x)
              return binarySearch(arr, l, mid - 1, x);
              // Si x es mayor, ignorar la derecha
              return binarySearch(arr, mid + 1, r, x);
          }
          return -1;
      }

.. |image1| image:: https://uniwebsidad.com/static/libros/imagenes/algoritmos-python/f0801.png
