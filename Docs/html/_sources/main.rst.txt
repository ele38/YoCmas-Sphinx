Estructuras de datos
====================

Estructuras lineales
--------------------

Acerca de
~~~~~~~~~

Rellenar p√°gina

Arrays (arreglos)
~~~~~~~~~~~~~~~~~

Los arrays son conjuntos de datos que se almacenan en memoria de manera
contigua usando el mismo nombre. Se usan √≠ndices para diferenciar los
distintos valores del arreglo. Para crear una arreglo es necesario saber
la cantidad de elementos que van a componer nuestro arreglo, pues la
cantidad de elementos no se puede cambiar. Una cosa muy importante que
al principio uno suele olvidar es que los √≠ndices de los arreglos parten
en 0. Es decir, un arreglo de tama√±o n puede tomar √≠ndices desde el 0
hasta el n-1.

#. Inicializaci√≥n

   Hay dos formas de inicializar un array, especificando su tama√±o o
   llenandolo con valores por defecto.

   #. Inicializar un array por su tama√±o

      Para inicializar un array por su tama√±o, lo √∫nico que hay que
      especificar es el nombre de la variable y colocar entre "[]" el
      tama√±o de nuestro arreglo. Recordar que como los arrays parten en
      0, el valor m√°ximo que podremos acceder ser√° el tama√±o del array
      menos 1.

      .. code:: cpp
         :number-lines:

         int arreglo[38]; // Inicializar un arreglo de ints de tama√±o 38.

   #. Inicializar un array con valores por defecto

      Para inicializar un array con valores por defecto, no es necesario
      especificar el tama√±o de nuestro array, pues este est√° impl√≠cito
      en la cantidad de valores que introducimos.

      .. code:: cpp
         :number-lines:

         int arreglo2[] = {3, 6, 2, 1};

#. Leer el valor de un arreglo

   Para leer un valor de nuestro arreglo, solo hay que especificar el
   nombre del arreglo y su √≠ndice. Notar que s√≥lo se puede acceder a un
   valor de un arreglo a la vez.

   .. code:: cpp

      arreglo2[3]; // Retorna 1

#. Asignar valores a un arreglo

   Para esto, hay que especificar la variable, el √≠ndice al cu√°l acceder
   y especificar su nuevo valor. Recordar que el valor del √≠ndice puede
   ser una variable, pero que no puede estar fuera del rango del tama√±o
   de nuestro arreglo.

   .. code:: cpp
      :number-lines:

      arreglo2[3] = 5; // El indice 3 de nuestro arreglo, ahora tiene el valor 3

Arrays multidimensionales
~~~~~~~~~~~~~~~~~~~~~~~~~

Un array multidimensional es aquel que requiuere de m√°s de un √≠ndice
para ser llamado, como su nombre lo indica, es √∫til para cuando
necesitamos acceder a datos que requieren m√°s de una dimensi√≥n, como por
ejemplo valores dentro de una malla. Otra forma de enternder los arrays
multidimensionales es como un arreglo de arreglos (de arreglos de
arreglos.. n veces, siendo n la cantidad de dimensiones). Los arreglos
de 2 dimensiones tambi√©n son conocidos como matrices.

#. Inicializar un arreglo multidimensional

   Para esto, hay que especificar el tama√±o de cada dimensi√≥n del array.
   Notar que la regla de que empiezan en 0 y terminan en n-1 se sigue
   cumpliendo. Es posible asignarles valores predeterminados, pero creo
   que eso se va poniendo exponencialmente m√°s psic√≥pata a medida de que
   vas incrementando las dimensiones del array a crear, por lo que no lo
   voy a demostrar.

   .. code:: cpp
      :number-lines:

      int matriz[3][4];
      int tridimensional[100][100][100];

#. Asignar valores en un arreglo multidimensional

   Es muy similar a c√≥mo se hace en un arreglo unidimensional, solo que
   se especifica cada √≠ndice.

   .. code:: cpp
      :number-lines:

      int n = 3, m = 5;
      matriz[2][1] = 10;
      tridimensional[n][m] = 4;

Vectors (vectores)
~~~~~~~~~~~~~~~~~~

Los vectores son como arreglos, excepto de que el tama√±o es din√°mico, es
decir, se puede cambiar.

#. Inicializar un vector

   Incluimos la librer√≠a:

   .. code:: cpp
      :number-lines:

      #include <vector>

   Inicializamos nuestro vector "vec":

   .. code:: cpp
      :number-lines:

      int n = 3;
      vector < int > vec(n, 0); // Inicializa un vector de tama√±o 3 con todos sus valores = 0. Tanto el tama√±o como valor son opcionales.

#. Asignar un valor

   .. code:: cpp
      :number-lines:

      vec[2] = 1; // Asigna el valor "1" al √≠ndice 2 (es decir, al 3er valor del vector)

#. push back (empujar atr√°s)

   Si no sabemos el tama√±o de nuestro vector, podemos simplemente usar
   push\ :sub:`back`\ (valor); para enviar es valor al final del vector.

   .. code:: cpp
      :number-lines:

      vec.push_back(1); // Inserta un 1 al final del vector

   Por ejemplo, se podr√≠a usar en un for, sin necesidad de inicializar
   el vector con una cantidad de valores.

   .. code:: cpp
      :number-lines:

      vector <int> vec2;
      int n;
      cin >> n;
      for (int i = 0; i < n; ++i){
          int valor;
          cin >> valor;
          vec2.push_back();
      }

#. pop back (quitar atr√°s)

   Elimina el √∫ltimo valor del vector.

   .. code:: cpp
      :number-lines:

      vec.pop_back(); // En este caso, elimina el 1

#. insert (insertar)

   Podemos insertar un valor entre dos indices de un vector. El problema
   de esto es que mueve todos los valores que est√©n m√°s adelante, lo que
   es lento.

   .. code:: cpp
      :number-lines:

      vec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al √≠ndice 2

#. erase (borrar)

   Borra un dato del vector. Al igual que el insert, tiene que mover
   todos los datos siguientes (esta vez a la derecha).

   .. code:: cpp
      :number-lines:

      vec.erase(vec.begin() + 2); // Elimina el valor con √≠ndice 2, en nuestro caso, el 4 que insertamos antes.

#. Iteradores de un arreglo

   Hay ciertos iteradores que podemos usar en un arreglo que nos
   ayudar√°n en algunos casos, como por ejemplo si quieremos recorrer un
   arreglo. Estos son:

   -  begin() ‚Äì Iterador que accede al primer valor del arreglo.
   -  end() ‚Äì Accede al final del arreglo.
   -  rbegin() ‚Äì Accede al ultimo elemento del arreglo
   -  rend ‚Äì Accede al inicio del arreglo

Stacks (pilas)
~~~~~~~~~~~~~~

La pila es una estructura de datos lineal al que s√≥lo puedes acceder al
√∫ltimo elemento que fue insertado. Imagina una pila de platos, por
ejemplo.

.. code:: cpp
   :number-lines:

   stack < int > pilita;

#. push (empujar)

   Empuja un dato a la cima de la pila.

   .. code:: cpp
      :number-lines:

      pilita.push(8); // Empuja un 8 a la cima de la pila.

#. top (cima)

   Lee lo que hay en la cima de la pila.

   .. code:: cpp
      :number-lines:

      pilita.top(); // Retorna el 8.

#. pop (quitar)

   Remueve el dato de la cima de la pila.

   .. code:: cpp
      :number-lines:

      pilita.pop(); // Remueve el 8.

#. empty (vac√≠o)

   Retorna 1 si la pila est√° vac√≠a, de lo contrario retorna 0.

   .. code:: cpp
      :number-lines:

      pilita.empty(); // Retorna 1 ya que nuestra pila est√° vac√≠a.

#. size (tama√±o)

   Retorna el tama√±o de nuestra pila.

   .. code:: cpp
      :number-lines:

      pilita.size(); // Retorna 0 ya que nuestra pila no tiene datos.

Queues (colas)
~~~~~~~~~~~~~~

La cola es una estructura de datos lineal al que s√≥lo puedes acceder al
primer elemento que fue insertado. Imagina una fila de una caja de un
supermercado, por ejemplo.

.. code:: cpp
   :number-lines:

   queue < int > colita;

#. push (empujar)

   A√±ade un dato al final de la cola.

   .. code:: cpp
      :number-lines:

      colita.push(5);
      colita.push(4);
      colita.push(3);
      colita.push(2);
      colita.push(1);

#. front (frente)

   Lee el dato que est√° al frente de la cola.

   .. code:: cpp
      :number-lines:

      colita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola.

#. pop (quitar)

   Remueve el dato que est√° al frente de la cola

   .. code:: cpp
      :number-lines:

      colita.pop();   // Remueve el 5
      colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora est√° primero).

#. empty (vac√≠o)

   Retorna 1 si la cola est√° vac√≠a, de lo contrario retorna 0.

   .. code:: cpp
      :number-lines:

      colita.empty(); // Retorna 1 ya que nuestra cola est√° vac√≠a.

#. size (tama√±o)

   Retorna el tama√±o de nuestra cola.

   .. code:: cpp
      :number-lines:

      colita.size(); // Retorna 0 ya que nuestra cola no tiene datos.

Estructuras en forma de √°rbol
-----------------------------

.. _acerca-de-1:

Acerca de
~~~~~~~~~

V√©ase: arbol binario

Set (conjunto)
~~~~~~~~~~~~~~

Es una lista que no permite que hayan elementos repetidos.

#. Inicializaci√≥n

   Incluimos la librer√≠a:

   .. code:: cpp
      :number-lines:

      #include <set>

   Inicializamos nuestro conjunto:

   .. code:: cpp
      :number-lines:

      set < int > conjunto; // int puede ser reemplazado con cualquier otro tipo de dato

#. insert (Insertar)

   Inserta un dato. Retorna un par de elementos, el primero siendo el
   iterador del valor insertado y el segundo siendo un bool que marca si
   es que ya exist√≠a o no. En el ejemplo de abajo, usamos .second para
   comprobar si se insert√≥ correctamente o no.

   .. code:: cpp
      :number-lines:

      if (conjunto.insert(10).second) // Retorna TRUE ya que no estaba anteriormente
          cout << "ganai\n"; if (conjunto.insert(10).second); // Retorna FALSE ya que ya hab√≠a un 10.
      cout << "no ganai\n";
      conjunto.insert(20);
      conjunto.insert(40);
      conjunto.insert(30);
      conjunto.insert(11);

#. find (Encontrar)

   Busca un elemento en el set y si lo encuentra retorna un iterador al
   valor. De lo contrario, retorna conjunto.end();

   .. code:: cpp
      :number-lines:

      if (conjunto.find(10) != conjunto.end())
          cout << "ganai\n";

#. erase (borrar)

   Puedes borrar un valor si le entregas el iterador al valor.

   .. code:: cpp
      :number-lines:

      set < int >::iterator it = conjunto.find(11);
      if (it != conjunto.end())
          conjunto.erase(it);

#. Iterar a trav√©s de un conjunto

   Puedes iterar a trav√©s de un conjunto con los valores ya ordenados
   con un iterador:

   .. code:: cpp
      :number-lines:

      // Imprime 10 11 20 30 40
      for (it = conjunto.begin(); it != conjunto.end(); ++it)
          cout << *it << " ";
      cout << '\n';

Map (mapa, tabla de hashing)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo
logar√≠tmico con la implementaci√≥n de la STL. Pero con otras
implementaciones se puede hacer en tiempo constante. Las llaves no se
pueden repetir.

#. Ejemplo cotidiano

   Libros:

   ============================ ===============
   T√≠tulo (Llave)               Autor (Valor)
   ============================ ===============
   The C Programming Language   Brian Keringhan
   The AWK Programming Language Brian Keringhan
   1984                         George Orwell
   ============================ ===============

   Curso:

   ======== ===================================
   Apellido Cantidad de alumnos con el apellido
   ======== ===================================
   Gonzalez 3
   Perez    2
   ======== ===================================

#. Inicializar

   Incluimos la librer√≠a de map:

   .. code:: cpp
      :number-lines:

      #include <map>

   Inicializamos el mapa curso:

   .. code:: cpp
      :number-lines:

      map<string, int> curso;

#. Insert (insertar)

   Forma 1:

   .. code:: cpp
      :number-lines:

      curso["perez"] = 1;

   Forma 2:

   .. code:: cpp
      :number-lines:

      curso.insert(pair<string, int>("gonzalez, 3"));

#. Operar con los valores

   Se puede operar con el valor tomando la llave. Ejemplo 1:

   .. code:: cpp
      :number-lines:

      ++curso.["perez"]; // Incrementar el valor de la llave perez, por ejemplo.

   Ejemplo 2:

   .. code:: cpp
      :number-lines:

      cout << curso.["perez"] << endl; // El output ser√° 2.

   Cuidado con operar con valores no existentes, pues los inicializar√°
   de una forma inesperada.

#. Find (encontrar)

   Retorna un iterador, si no lo encuentra, apunta a map.end() Asignamos
   el iterador it a gonzalez, y luego lo usamos:

   .. code:: cpp
      :number-lines:

      map<string, int>::iterator it;
      it = curso.find("gonzalez");

      if (it != curso.end()){
      cout << "Hay " << it->second << " " << it->first << " en el curso:\n";
      cout << "Llave: " << it->first << " Valor: " << it->second << '\n';
      }

   Podemos incluso operar usando los iteradores:

   .. code:: cpp
      :number-lines:

      it->++second;

#. Erase (borrar)

   Forma 1:

   .. code:: cpp
      :number-lines:

      it = curso.find("perez");
      curso.erase(it);

   Forma 2:

   .. code:: cpp
      :number-lines:

      curso.erase("gonzalez");

#. Recorrer los valores de un mapa

   Es exactamente igual que en un conjunto:

   .. code:: cpp
      :number-lines:

      for (it = curso.begin(); it != curso.end(); ++it){
          cout << "Llave: " << it->first << " Valor: " << it->second << '\n';
      }

#. Dudas que no dejan dormir

   #. ¬øQu√© pasa si modifico una llave?

      No se puede, tu c√≥digo no compilar√° pues es ilegal hacerlo üëÆüöìüö®

   #. ¬øPuedo buscar con el second?

      No, en ese caso recomendamos otra estructura, o tener dos maps üëÄ

   #. ¬øPuedo tener un map dentro de un map?

      Si, pero es de psic√≥pata buscar dentro de ese map.

Algoritmos de ordenamiento
==========================

.. _acerca-de-2:

Acerca de
---------

Un algoritmo de ordenamiento es aquel que toma los elementos de una
estructura y les asigna un orden. Cada algoritmo de ordenamiento tiene
su forma de operar, y podr√≠a ayudar a conseguir la respuesta a un
problema, no necesariamente por el resultado del ordenamiento.

Algoritmos de fuerza bruta
--------------------------

.. _acerca-de-3:

Acerca de
~~~~~~~~~

Rellenar

Bubble sort
~~~~~~~~~~~

-  Se van comparando los elementos, haciendo que los m√°s grandes suban
   en el arreglo, como una burbuja.
-  Da lo mismo c√≥mo est√©n ordenadas las cosas, porque puedes modificar
   la funci√≥n de comparaci√≥n.
-  Funciona invirtiendo el orden de cada par de elementos, si es que el
   primero es mayor que el segundo.
-  Por ejemplo, se podr√≠a usar para contar el n√∫mero de inversiones que
   hay que hacer.

#. Ejemplo

   ===== ===== ===== =====
   *5*   *3*   4     1
   3     *5*   *4*   1
   3     4     *5*   *1*
   3     4     1     **5**
   *3*   *4*   1     **5**
   3     *1*   *4*   **5**
   3     1     **4** **5**
   *3*   *1*   **4** **5**
   1     **3** **4** **5**
   **1** **3** **4** **5**
   ===== ===== ===== =====

#. C√≥digo de ejemplo:

   .. code:: cpp

      void bubblesort (vector<int> &vec) {
          int size = vec.size();
          for (int i = size-1; i > 0; --i) {
              for (int j = 0; j < i; ++j) {
                  if (vec[j] > vec[j+1]) {
                      int aux = vec[j];
                      vec[j] = vec[j+1];
                      vec[j+1] = aux;
                  }
              }
          }
          return;
      }

Insertion sort
~~~~~~~~~~~~~~

-  Se va de izquierda a derecha, se compara el segundo con el primero,
   se intercambian si el segundo es menor, si este es el caso, se vuelve
   a preguntar si el de la izquierda es menor al de mas a la izquierda y
   as√≠ hasta que se encuentre un caso en el que no o se llegue al
   principio del arreglo.

#. Rellenar ejemplo

#. Rellenar codigo de ejemplo

Algoritmos de "decrecer y conquistar"
-------------------------------------

.. _acerca-de-4:

Acerca de
~~~~~~~~~

Rellenar

Selection sort
~~~~~~~~~~~~~~

-  Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los
   elementos resantes.
-  El arreglo ya ordenado parte vac√≠o.
-  Busca el valor m√≠nimo entre los elementos no ordenados y lo a√±ade al
   final de los ordenados.

#. Rellenar ejemplo

#. Rellenar codigo de ejemplo

Algoritmos de b√∫squeda
======================

B√∫squeda binaria
----------------

.. _acerca-de-5:

Acerca de
~~~~~~~~~

La b√∫squeda binaria es un algoritmo de *divide and conquer* (dividir y
conquistar), que nos permite encontrar un elemento dentro de una
estructura **ordenada** r√°pidamente. Al ejecutarse, toma el centro de un
arreglo y comprueba si el valor que se busca es igual al del centro. De
no serlo, verifica si el valor es menor o mayor al del centro.

Si el valor es mayor al del centro, se ignoran todos los valores
anteriores al centro, dividiendo la cantidad de n√∫meros a la mitad.

Si el valor es menor al del centro, se ignoran todos los valores de
despu√©s del centro, dividiendo la cantidad de n√∫meros a la mitad.

La complejidad de este algoritmo es **Olog(N)**, comparada con un
algoritmo lineal, que en el peor de los casos tiene complejidad
**O(N)**.

#. Ejemplos

   #. en la vida real

      Ir al medio de un diccionario, y buscar alfab√©ticamente, tomando
      una palabra central (m√°s o menos), viendo si la palabra que
      queremos est√° antes o despu√©s y repetir el proceso de buscar una
      palabra central.

   #. Ejemplo computacional

      En esta im√°gen, se usa la b√∫squeda binaria para encontrar el 19.
      |image1|

Uso mediante la librer√≠a STL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. Importar

   Podemos directamente importar toda la stl o podemos importar la
   librer√≠a <algorithm> de la siguiente forma:

   .. code:: cpp
      :number-lines:

      #include <algorithm>

#. binary\ :sub:`search`\ ()

   La librer√≠a STL ya incluye binary search, si queremos saber si el
   valor 3 est√° en un vector, podemos ejecutar:

   .. code:: cpp
      :number-lines:

      vector<int> v{1,2,5,7};
      if (binary_search (v.begin(), v.end(), 3)) {
          cout << "Se encuentra el valor 3 en nuestro vector\n";
      }
      else {
          cout << "No hay ning√∫n 3 en nuestro vector\n";
      }

   Retorna un *bool*.

#. lower\ :sub:`bound`\ () (l√≠mite inferior)

   La funci√≥n lower\ :sub:`bound`\ () de la librer√≠a STL retorna un
   puntero a un valor **superior** o, si es posible, **igual** al
   entregado dentro de una estructura ordenada.

   Si todos los elementos en el arreglo son inferiores al valor pedido,
   se entrega el √∫ltimo elemento del arreglo. Si los elementos del
   arreglo son superiores al valor pedido, se entrega el primer elemento
   del arreglo.

   Por ejemplo:

   .. code:: cpp
      :number-lines:

      vector<int> v{ 10, 20, 30, 30, 30, 40, 50 };
      *lower_bound(v.begin(), v.end(), 30);

   Valor de retorno: un iterador que apunta hacia **30** (el primero en
   el arreglo, en la posici√≥n [2])

#. upper\ :sub:`bound`\ () (l√≠mite superior)

   La funci√≥n upper\ :sub:`bound`\ () de la librer√≠a STL nos entrega un
   puntero a un valor **superior** al pedido en un arreglo ordenado.

   En el caso de que no haya un valor superior al pedido, nos entrega el
   √∫ltimo valor del arreglo.

   Por ejemplo:

   .. code:: cpp
      :number-lines:

      *upper_bound(v.begin(), v.end(), 30);

   Valor de retorno: iterador al **40** (posici√≥n [4])

Implementaciones propias
~~~~~~~~~~~~~~~~~~~~~~~~

#. Implementaci√≥n con while

   Esta implementaci√≥n nos retorna el √≠ndice del n√∫mero a buscar dentro
   de un arreglo.

   .. code:: cpp
      :number-lines:

      int binarySearch(int arr[], int l, int r, int x)
      {

          while (l <= r) {
              int m = l + (r - l) / 2;

              // Revisa si x esta al medio
              if (arr[m] == x)
              return m;

              // Si x es mayor, ignorar la izquierda
              if (arr[m] < x)
              l = m + 1;

              // Si x es menor, ignorar la derecha
              else
              r = m - 1;

          }
          return -1;

      }

#. Implementaci√≥n recursiva

   Esta implementaci√≥n nos retorna el √≠ndice del n√∫mero a buscar dentro
   de un arreglo.

   .. code:: cpp
      :number-lines:

      int binarySearch(int arr[], int l, int r, int x)
      {

          if (r >= l) {

              int mid = l + (r - l) / 2;

              // Revisa si x esta al medio

              if (arr[mid] == x)
              return mid;

              // Si x es mayor, ignorar la izquierda
              if (arr[mid] > x)
              return binarySearch(arr, l, mid - 1, x);
              // Si x es mayor, ignorar la derecha
              return binarySearch(arr, mid + 1, r, x);
          }
          return -1;
      }

.. |image1| image:: https://uniwebsidad.com/static/libros/imagenes/algoritmos-python/f0801.png
